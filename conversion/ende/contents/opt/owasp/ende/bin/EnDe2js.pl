#! /usr/bin/perl -w
# vi:  ts=8
# vim: ts=8
#?
#? NAME
#?      $0 - XML/HTML/js/txt generator
#?
#? SYNOPSIS
#?      $0 file1 file2 ...
#?      $0 -nofoot file1 -nohead -nofoot file2 -nohead file3 ...
#?
#? OPTIONS
#?      -nohead - do not print file header
#?      -nofoot - do not print file footer
#?      -attr   - print XML tag with attributes: <attack id=... type=...>
#?
#? DESCRIPTION
#?      Generate list of functions from given file as XML or JavaScript data.
#?
#?      Type of output data, XML, HTML, JavaScript or tabular text depends on
#?      name of the script, if the sciptname matches:
#?        *2xml     - XML data is generated
#?        *2txt     - tabular text data is generated
#?        *2html    - HTML data is generated
#?        *2js      - JavaScript data is generated
#?
#?   Given (expected) data:
#?      var EnDe    = new function()  {
#?      this.OBJECT = new function(par1,par2,par3) {
#?        this.FUNC = function(par1,par2,par3) {
#?        //#? description for function
#?        //#par1? 2nd: second description for function
#?        ...
#?        };
#?      }; // .OBJECT
#?
#?   Format of JavaScript file:
#?      EnDe.Func  = new function() {
#?       this.list = {
#?        OBJECT: {
#?          FUNC:    [EnDe.OBJECT.FUNC (par1,par2,par3), "description for function"],
#?          FUNC:    [EnDe.OBJECT.FUNC ('2nd',par2,par3), "second description for function"],
#?           ...
#?          desc:    'OBJECT'
#?        }, // OBJECT
#?       }; // .list
#?      }; // .Func
#?
#?   Format of XML file:
#?      <xml>
#?          <attack>
#?              <label>EnDe.OBJECT</label>
#?              <name>FUNC</name>
#?              <code>CODE</code>
#?              <code><![CDATA[EnDe.OBJECT.FUNC(par1,par2,par3) ]]></code>
#?              <desc>description for function</desc>
#?          </attack>
#?          <attack>
#?              <label>EnDe.OBJECT</label>
#?              <name>FUNC</name>
#?              <code>CODE</code>
#?              <code><![CDATA[EnDe.OBJECT.FUNC("2nd",par2,par3) ]]></code>
#?              <desc>second description for function</desc>
#?          </attack>
#?           ...
#?
#?   Format of HTML file:
#?      <table>
#?          <tr>
#?              <th title="EnDe.OBJECT">FUNC</th>
#?              <td>par1,</td><td>par2,</td><td>par3)</td></tr>
#?          <tr><td colspan=10>description for function</td></tr>>
#?           ...
#?
#?   Format of text file: 
#?      Note that spearator between columns are TABs.
#?      #------+---------------+---------------+-----------------------------------
#?      #key    code            name            desc
#?      #------+---------------+---------------+-----------------------------------
#?      group   EnDe.OBJECT     EnDe.OBJECT     EnDe.OBJECT
#?      item3   EnDe.OBJECT.FUNC(par1,par2,par3)   FUNC   description for function
#?      ...
#?      #------+---------------+---------------+-----------------------------------
#?      menu    EnDeFunc        EnDe function:  EnDe function call
#?      html    SELECT
#?      inside  EnDeDOM.f.FF
#?      id      EnDeDOM.f.FF.func
#?      size    1
#?      onClick return EnDeGUI.dispatch(this,this.value);
#?      use     EnDe
#?      use     EnDe.OBJ
#?      ...
#?
# HACKER's INFO
#       Generation of HTML, JSON and JS output is as simple as possible. Hence
#       we keep some spaces in the function definition and also use a seperate
#       column for opening and closing round brackets.
#
#? SEE ALSO
#?      EnDe.js
#?
#? VERSION
#?      @(#) EnDe2js.pl 3.17 12/06/10 13:00:39
#?
#? AUTHOR
#?      28-jun-08 Achim Hoffmann, mailto: EnDe (at) my (dash) stp (dot) net
#?
# -----------------------------------------------------------------------------

my $debug= 0;
my $mode = $0;
$mode = 'TXT'  if ($mode =~ m/2txt.pl$/);
$mode = 'XML'  if ($mode =~ m/2xml.pl$/);
$mode = 'JSON' if ($mode =~ m/2json.pl$/);
$mode = 'JS'   if ($mode =~ m/2js.pl$/);
$mode = 'HTML' if ($mode =~ m/2html.pl$/);
if ($mode eq $0) {
	print "**ERROR $0: unknown mode; exit";
	exit 2;
}

# global list of groups
%::g = (); # ugly to use a global here
# global store for last function parameters (quick&dirty hack)
$::name = '';
$::func = '';
$::line = '';
$::parm = ''; # unused
$::type = ''; # unused

sub resetfunc() {
	$::name = '';
	$::func = '';
	$::line = '';
	$::parm = '';
	$::type = '';
}
sub storefunc($$$$$) {
	$::name = shift;
	$::func = shift;
	$::line = shift;
	$::parm = shift;
	$::type = shift;
}

sub phead($$$) {
	my $mode = shift;
	my $src  = shift;
	my $obj  = shift; # object
	my $sid  = $src;  # use SID from inputfile (EnDe.js)
	   $sid  =~ s/[^\s]*\s+(\d+\.\d+)\s.*/$1/;
	my $txt  = '@(#) EnDeFunc.' . lc($mode) . ' ' . $sid . ' ; generated by EnDe2js.pl 3.17  from: ' . $src;
	my $use  = 'parameters named _n1_, _n2_, .. _n7_ are unused parameters for that function';
	if ($mode eq 'XML') {
		print "<?xml version=\"1.0\"?>\n";
		print "<!-- $txt -->\n";
		print "<!-- $use -->\n";
		print "<xss>\n";
	}
	if ($mode eq 'TXT') {
		print "# $txt\n"; 
		print "# $use\n";
		print "# format of content herein see EnDeMenu.txt\n";
	}
	if ($mode eq 'JS') {
		$obj =~ s/^EnDe/EnDe.Func/;
		print "// $txt\n"; 
		print "/*\n * $use\n */\n";
		print "if (typeof(EnDe)==='undefined') { EnDe = new function() {}; }\n";
		print "$obj   = new function() {\n\tthis.SID    = '$sid';\n\tthis.list   = {\n ";
	}
	if ($mode eq 'HTML') {
		print "<html><head><title>EnDe Functions</title>\n"; 
		print "<meta name=\"DC.Source\" content=\"$txt\" />\n"; 
		print "<style type=\"text/css\">\n";
		print "th.f { background-color:#c0c0c0; text-align:right; }\n";
		print "th.h { background-color:#c0c0c0; text-align:left;  }\n";
		print "td.l { font-style:italic; border-bottom:1px solid black }\n";
		print "</style>\n";
		print "</head><body>\n";
		print "<div> $use </div>\n";
		print "<table style=\"border:1px solid black\">\n";
		print "<caption>List of Functions</caption>\n";
		print "<th colspan=\"10\" class=\"h\">$obj</th></tr>\n";
	}
}

sub pfunc($$$$$$$$) {
	# convert given line to output format specified in mode
	my $mode = shift; # mode for output format
	my $name = shift; # function name to be prnted
	my $func = shift; # full object name
	my $line = shift; # source line to be converted
	my $parm = shift; # name of special parameter (see type)
	my $type = shift; # type of parameter param
	my $idx  = shift; # unique ID used as XML attribute
	my $attr = shift;
	#dbx print "\n"; chomp $line;
	#dbx print "##line: $line\n";
	#dbx print "##name: $name\n";
	#dbx print "##func: $func\n";
	#dbx print "##parm: $parm\n";
	#dbx print "##type: $type\n";
	#dbx print "##attr: $attr\n";
	#dbx print "##idx: $idx\n";
	if (($name eq '') or ($func eq '')) {
	   $name = $::name;
	   $func = $::func;
	   $line = $::line;
	   #$type = $::type;
	}
	if ($mode eq 'HTML') {
		# generate prototype key:value
		$name =~ s# *$##;
		$line =~ s#^  #   _#;
		$line =~ s#this\.#<tr><th title="$func.$name"\tclass=\"f\" >#;
		$line =~ s#\s*=\s*function\s*\(#</th><td>(</td><th>#;
		# "**double quote in previous substitute**";
		$line =~ s#,#,</th><th>#g;
		$line =~ s#\).*$#</th><td>)</td></tr>#;
		# "**double quote in previous substitute**";
		if ($type ne '') {
			$line =~ s#$parm#'$type'#g;
		}
		print $line;
	}
	if ($mode eq 'JS') {
		# generate prototype key:value
		$line =~ s/^  /    /;
		$line =~ s/this\./$name:\t[$func\./;
		$line =~ s/\s*=\s*function\s*\(/\t(/;
		# "**double quote in previous substitute**";
		$line =~ s/,/,\t/g;
		$line =~ s/uppercase/upper/g;
		$line =~ s/delimiter/delim/g;
		$line =~ s/\).*$/),/;
		# "**double quote in previous substitute**";
		$line =~ s/\n//;
		# replce type by value, if any
		if ($type ne '') {
			$line =~ s/$parm/'$type'/g;
		}
		print $line;
	}
	if ($mode eq 'TXT') {
		my $f = $name;
		my $displaymode = 'full';       # not yet used
		if ($displaymode eq 'simple') {
			# item3 f(a,b,c) EnDe.f
			$f =~ s#\s*$##;
			$f = "$func.$f";
			$line =~ s#^( *)#item3\t#;
			$line =~ s#this\.##;
			$line =~ s#\s*=\s*function\s*\(#(#;
			$line =~ s#\).*$#)\t$f#;
		} else {
			# item3 EnDe.f(a,b,c) f(a,b,c)
			$f =  $line;
			$f =~ s#\s*this\.##;
			$f =~ s#\s*=\s*function\s*\(#(#;
			$f =~ s#\s*\).*$#)#;
			$f =~ s#\n##;
			$line = "item3\t$func.$f\t$f";
		}
		if ($type ne '') {
			$line =~ s#$parm#'$type'#g;
		}
		# have a valid "item3" line for the menu file now, just the
		# description is missing which will come from another line
		# in case no description is following a \t\n is added to
		# make the line completetly valid for reading in EnDeFile.js
		$::g{$func} .= $line . "\t\n";
	}
	if ($mode eq 'XML') {
		# generate XML tags
		my $typ = '';
		my $obj = 'EN'; # ToDo: all other objetcs not yet implemented
		$obj  = 'EN' if ($func =~ m/^EnDe\.EN/);
		$obj  = 'DE' if ($func =~ m/^EnDe\.DE/);
		$obj  = 'RE' if ($func =~ m/^EnDe\.RE/);
		$obj  = 'IP' if ($func =~ m/^EnDe\.IP/);
		$line =~ s#this\.#\t<code><![CDATA[$func\.#;
		$line =~ s#\s*=\s*function\s*\(#(#;
		$line =~ s#{.*# ]]></code>#;
		$line =~ s/src/\$('EnDeDOM.$obj.text').value/g if ($obj ne 'XX');
		$line =~ s/mode/\"lazy"/g;      # ToDo: wrong but we have EnDeDOM.API.mode[012]
		# replce type by value, if any
		if ($type eq '') {
			$line =~ s/type/\"null"/g;  # // ToDo: wrong as we don't have the types yet
		} else {
			$line =~ s/$parm/\"$type"/g;
		}
		$line =~ s/(uppercase)/\$('EnDeDOM.API.$1').checked/g;
		$line =~ s/(delimiter|prefix|suffix)/\$('EnDeDOM.API.$1').value/g;
		if ($line  =~ m/.*?\("([^"]*)".*/) {
			$typ  = $line;
			$typ  =~ s/.*?\("([^"]*)".*/$1/;
			$typ  =~ s/\n//g; # don't know why needed
		}
		print "    <attack";
		print ' id="' . $idx . '" name="' . $name . "('" . $typ . "')" if ($attr != 0);
		print ">\n";
		print "\t<label>$func</label>\n";
		print "\t<name>$func.$name</name>\n";
		print "$line";
	}
}

sub pdesc($$$) {
	my $mode = shift;
	my $line = shift;
	my $func = shift;
	if ($func eq '') {
	   $func = $::func;
	}
	if ($mode eq 'JS') {
		$line =~ s/'/\\'/g;
		$line =~ s/\\/\\\\/g;
		print "\t'$line'],\n";
	}
	if ($mode eq 'TXT') {
		$::g{$func} =~ s/\n$//; # remove trailing \n 
		$::g{$func} =~ s/\t$//; # remove trailing \t 
		$::g{$func} .= "\t$line\n";
	}
	if ($mode eq 'XML') {
		print "\t<desc><![CDATA[$line]]></desc>\n";
		print "    </attack>\n";
	}
	if ($mode eq 'HTML') {
		print "<td colspan=\"2\" class=\"l\">&#160;</td><td colspan=\"8\" class=\"l\">$line</td></tr>\n";
	}
}

sub pfoot($$) {
	my $mode = shift;
	my $line = shift;
	if ($mode eq 'JS') {
		print "  desc: '$line'\n\t}; // .list\n};\n";
		#print "var EnDeFunc = new _EnDeFunc();\n"
	}
	if ($mode eq 'XML') {
		print "</xss>\n";
	}
	if ($mode eq 'HTML') {
		print "</table></body></html>\n";
	}
	if ($mode eq 'TXT') {
		# // ToDo: note that hardcoded EnDeFunc.txt must match filename
		#          see EnDeGUI.Obj.* for details
		print "\n";
		print "menu\tEnDeFunc.txt\tEnDe functions:\tEnDe function call\n";
		print "inside\tEnDeDOM.f.FF\n";
		print "id\tEnDeDOM.f.FF.func\n";
		print "html\tSELECT\n";
		print "size\t1\n";
		print "onClick\treturn EnDeGUI.dispatch(this,this.value);\n";
		print "use\tEnDe\n";
		foreach my $use (sort keys %g) {
			next if ($use =~ /^\s*$/);
			print "use\t$use\n" if ($use ne "EnDe");
		}
	}
}

# generated list of all functions
my @l;
my $cnt  = 0;
my $idx  = 0;
my $skip = 0;
my $noh  = 0;
my $nof  = 0;
my $attr = 0;
my $SID  = '';
undef $\;
while (my $arg = shift @ARGV) {
	# parse options and arguments
	# we allow list of filenames, each may be prefixed with its own options
	# this requires that we write a complete new "object" header for each
	# file; inside the file the header is omitted if a new object is found
	@l   = ();
	#$noh = 0;
	#$nof = 0;
	$attr= 0;
	if ($arg =~/-nohead/) { $noh = 1; next; }
	if ($arg =~/-nofoot/) { $nof = 1; next; }
	if ($arg =~/-attr/)   { $attr= 1; next; }
	$file= $arg;
	open(E,$file) or die "**ERROR $0: cannot open $file: $!";
	while(<E>) {
		my $sub = '';
		next      if ($skip eq 1);
		$skip = 1 if (m#^\s* }[ ;]*//\s*EnDe$#);
	
		# get version of source and print initial header
		if (m/^#\?\s*@.#..(.*)/) { $SID = $1; }
		#dbx if (m/^#\?\s*@.#..(.*)/) { print "## $1 ##\n"; }

		# find start of object and initialize level stack
		# // ToDo: HTTPGUI is temporary
		if (m/^(?:\s*var\s+)?(EnDe)\.?(AES|CRC|MD4|MD5|RMD|SHA|SHA5|B64|Blowfish|HTTPGUI|HTTP|IP|TS|Test)?\s+=/) {
			$sub = $2;
			$_=~s/EnDe/EnDe,Func/;
			push(@l,'EnDe');
			push(@l,$sub) if ($sub ne '');
			if ($noh==0) {
				phead($mode,$SID,join(".",@l));
			} else {
				if ($mode eq 'JS') {
					# //ToDo: JS is not yet ready
					phead($mode,$SID,join(".",@l));
				}
				if ($mode eq 'HTML') {
					# sme as below
					my $cnt = "&nbsp" x $#l; # very simple identation
					print "<tr><th colspan=\"10\" class=\"h\">$cnt " . join(".",@l) . "</th></tr>\n";
				}
			}
			next;
		}
	
		# find end of of sub-object; pop from stack
		if (m/^\s*\};(?:[\s]*)\/\/\s*([A-Za-z0-9_.]+)\s*$/) {
			# found comment for end of object block
			# now check if text right to last . matches last stored object
			my $sub = $1;
			$sub =~ s#.*?([A-Za-z0-9_]+)\s*$#$1#;
			#dbx print "## $_ -- $sub == $l[-1]\n";
			if ($l[-1]) {
				if ($sub eq $l[-1]) {
					pop(@l);
					if ($mode eq 'JS') {
						print "\t'dumm':'dumm'},\n";
					}
					next;
				}
			}
		}
	
		# find definition of sub-object; push to stack
		if (m/^\s*this\.([^\s]+)\s*=\s*new\s+function/) {
			push(@l,$1);
			if ($mode eq 'TXT') {
			}
			if ($mode eq 'JS') {
				print "\n  $1: {\n";
			}
			if ($mode eq 'HTML') {
				my $cnt = "&nbsp" x $#l; # very simple identation
				print "<tr><th colspan=\"10\" class=\"h\">$cnt " . join(".",@l) . "</th></tr>\n";
			}
			next;
		}
	
		# find end of object definition; pop from stack
		if (m#^\s*}[ ;]*//.*\.([^\s]+)\s*$#) {
			print "#".$. .": ".$1." == ".$l[$#l]  if $debug;
			if ($l[-1]) {
				if ($1 eq $l[$#l]) {
					my $n=pop(@l);
					if ($mode eq 'TXT') {
						#dbx print "## ",join(".",@l),"\n";
					}
					if ($mode eq 'JS') {
						print "    desc:\t'$n'\n";
						print "  }, // $n\n";
					}
					next;
				}
			}
		}
	
		# find function definition and print
		if (m/^\s*this\.(.+)\s*=\s*function/) {
			my $n = $1;
			my $f = join(".",@l);
			next if ($n=~/^(SID|sid|dbx|dpr)/); # internal function not needed
			$cnt++;
			$idx++;
			storefunc(  $n,$f,$_,'','');
			pfunc($mode,$n,$f,$_,'','',$idx,$attr);
			next;
		}
	
		# find description of function and print
		if (m:^\s*//\s*#\?\s*(.*)$:) {
			next if ($1=~/dpr/); # //ToDo:ugly hack (get rid of: "wrapper for EnDeGUI.dpr()"
			pdesc($mode,$1,'');
			next;
		}
	
		# find further description of function and print
		if (m:^\s*//\s*#(\w+)\?\s*(.*)$:) {
			my $desc = $2;
			my $parm = $1;
			my $type = $2;
			$idx++;
			$type =~ s/^([^\s:]*)[\s:].*/$1/;
			pfunc($mode,'','','',$parm,$type,$idx,$attr); # uses values from global store
			pdesc($mode,$desc,'');
			next;
		}
	} # while <E>
	if ($mode eq 'JS') {
		# //ToDo: JS is not yet ready
		pfoot($mode,$cnt);
	}
	if ($mode ne 'HTML') {
		pfoot($mode,$cnt) if ($nof==0);
	}
	if ($mode ne 'JSON') {
		pfoot($mode,$cnt) if ($nof==0);
	}
	if ($mode ne 'TEXT') {
		# does not have a footer
	}
	if ($mode ne 'XML') {
		pfoot($mode,$cnt) if ($nof==0);
	}
} # while @ARG
if ($mode eq 'TXT') {
	my $use;
	foreach $use (keys %g) {
		if ($use =~ /^\s*$/) {
			print "\n## WARNING: ignoring group with empty name:\n";
			my $txt = $::g{$use};
			$txt =~ s/\n/##\n/sg;
			#print $txt;
			next;
		}
		print "\ngroup\t$use\t$use\t$use\n";
		print "$::g{$use}\n";
	}
	print "\n";
	pfoot($mode,$cnt);
}

exit(0);
