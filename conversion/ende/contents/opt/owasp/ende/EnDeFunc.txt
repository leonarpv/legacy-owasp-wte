# @(#) EnDeFunc.txt 3.6 ; generated by EnDe2js.pl 3.17  from: aes.js 3.6 12/06/03 12:54:55
# parameters named _n1_, _n2_, .. _n7_ are unused parameters for that function
# format of content herein see EnDeMenu.txt

## WARNING: ignoring group with empty name:

group	EnDe.HTTP.DE	EnDe.HTTP.DE	EnDe.HTTP.DE
item3	EnDe.HTTP.DE.header(src)	header(src)	parse HTTP message headers, return hash {'head': value, ... }
item3	EnDe.HTTP.DE.body(src)	body(src)	parse HTTP message body, return hash {'key': value, ... }
item3	EnDe.HTTP.DE.parse(src)	parse(src)	parse given source and store data in EnDe.HTTP.request, EnDe.HTTP.response
item3	EnDe.HTTP.DE.get(typ,dst,src)	get(typ,dst,src)	get value of specified typ from dst


group	EnDe.TS	EnDe.TS	EnDe.TS
item3	EnDe.TS.u2a(ts)	u2a(ts)	convert Unix to windows ASP.NET (64bit) timestamp; ts have to be in millisecond format
item3	EnDe.TS.w2a(ts)	w2a(ts)	convert windows TDateTime (32bit) to ASP.NET (64bit) timestamp
item3	EnDe.TS.d2a(ts)	d2a(ts)	convert DOS (32bit) to ASP.NET (64bit) timestamp
item3	EnDe.TS.o2a(ts)	o2a(ts)	convert OLE to ASP.NET (64bit) timestamp
item3	EnDe.TS.a2u(ts)	a2u(ts)	convert windows ASP.NET (64bit) to Unix timestamp; ts returned in millisecond format
item3	EnDe.TS.a2d(ts)	a2d(ts)	convert windows ASP.NET (64bit) to DOS (32bit) timestamp
item3	EnDe.TS.a2o(ts)	a2o(ts)	convert windows ASP.NET (64bit) to OLE timestamp
item3	EnDe.TS.a2w(ts)	a2w(ts)	convert windows ASP.NET (64bit) to TDateTime (32bit) timestamp
item3	EnDe.TS.w2u(ts)	w2u(ts)	convert windows TDateTime (32bit) to Unix timestamp; ts returned in millisecond format
item3	EnDe.TS.u2w(ts)	u2w(ts)	convert Unix to windows TDateTime (32bit) timestamp; ts have to be in millisecond format
item3	EnDe.TS.matchTime(_n1_,_n2_,year2digits,strict,now,src)	matchTime(_n1_,_n2_,year2digits,strict,now,src)	try to match a time value
item3	EnDe.TS.matchOffset(_n1_,_n2_,year2digits,strict,now,src)	matchOffset(_n1_,_n2_,year2digits,strict,now,src)	check if value is a timestamp offset
item3	EnDe.TS.matchDateTime(_n1_,_n2_,year2digits,strict,now,src)	matchDateTime(_n1_,_n2_,year2digits,strict,now,src)	try to match a date/time value
item3	EnDe.TS.joinTime(hor)	joinTime(hor)	return human readable time h:m:s
item3	EnDe.TS.joinEmit(hor)	joinEmit(hor)	return human readable time s:m:h
item3	EnDe.TS.joinDate(hor)	joinDate(hor)	return human readable date Y/M/D
item3	EnDe.TS.joinEtad(hor)	joinEtad(hor)	return human readable date D/M/Y
item3	EnDe.TS.guessInt(src)	guessInt(src)	guess time ..
item3	EnDe.TS.guessOffset(src)	guessOffset(src)	guess time offset
item3	EnDe.TS.guess(src)	guess(src)	guess date/time ..


group	EnDe.SHA.sha1.hmac	EnDe.SHA.sha1.hmac	EnDe.SHA.sha1.hmac
item3	EnDe.SHA.sha1.hmac.hex(key, s)	hex(key, s)	
item3	EnDe.SHA.sha1.hmac.b64(key, s)	b64(key, s)	
item3	EnDe.SHA.sha1.hmac.str(key, s)	str(key, s)	
item3	EnDe.SHA.sha1.hmac.core(key, data)	core(key, data)	


group	EnDe.SHA.sha1	EnDe.SHA.sha1	EnDe.SHA.sha1
item3	EnDe.SHA.sha1.ft(t, b, c, d)	ft(t, b, c, d)	
item3	EnDe.SHA.sha1.kt(t)	kt(t)	
item3	EnDe.SHA.sha1.core(x,len)	core(x,len)	
item3	EnDe.SHA.sha1.test()	test()	
item3	EnDe.SHA.sha1.hex(s)	hex(s)	
item3	EnDe.SHA.sha1.b64(s)	b64(s)	
item3	EnDe.SHA.sha1.str(s)	str(s)	


group	EnDe.DE	EnDe.DE	EnDe.DE
item3	EnDe.DE.chr(_n1_,_n2_,_n3_,src,prefix,suffix,delimiter)	chr(_n1_,_n2_,_n3_,src,prefix,suffix,delimiter)	convert string to list of characters with prefix, delimiter and suffix
item3	EnDe.DE.url(type,mode,src,prefix,suffix,delimiter)	url(type,mode,src,prefix,suffix,delimiter)	convert URL encoded text to plain text
item3	EnDe.DE.url('null',mode,src,prefix,suffix,delimiter)	url('null',mode,src,prefix,suffix,delimiter)	null: just convert each %HH value
item3	EnDe.DE.url('utf8',mode,src,prefix,suffix,delimiter)	url('utf8',mode,src,prefix,suffix,delimiter)	utf8: convert each %HH value, then convert UTF-8 characters
item3	EnDe.DE.url('utf8c',mode,src,prefix,suffix,delimiter)	url('utf8c',mode,src,prefix,suffix,delimiter)	utf8c: convert each %HH value, then convert UTF-8 characters (with high bit set)
item3	EnDe.DE.ucs(type,mode,src,prefix,suffix,delimiter)	ucs(type,mode,src,prefix,suffix,delimiter)	convert URL encoded (none US ASCII Unicode) text to plain text
item3	EnDe.DE.ucs('url2',mode,src,prefix,suffix,delimiter)	ucs('url2',mode,src,prefix,suffix,delimiter)	url2: convert %HH%HH strings
item3	EnDe.DE.ucs('url4',mode,src,prefix,suffix,delimiter)	ucs('url4',mode,src,prefix,suffix,delimiter)	url4: convert %uHHHH strings (see EnDe.DE.num('hex',...) also)
item3	EnDe.DE.ucs('ucs4',mode,src,prefix,suffix,delimiter)	ucs('ucs4',mode,src,prefix,suffix,delimiter)	ucs4: convert \uHHHH strings
item3	EnDe.DE.num(type,mode,src,prefix,suffix,delimiter,len)	num(type,mode,src,prefix,suffix,delimiter,len)	convert numeric encoded text to plain text; internal function, don't use in API
item3	EnDe.DE.numstr(type,mode,src,prefix,suffix,delimiter)	numstr(type,mode,src,prefix,suffix,delimiter)	convert hex, decimal or octal encoded text to plain text
item3	EnDe.DE.hex(type,mode,src,prefix,suffix,delimiter)	hex(type,mode,src,prefix,suffix,delimiter)	convert hex-based encoded text to plain text
item3	EnDe.DE.dez(type,mode,src,prefix,suffix,delimiter)	dez(type,mode,src,prefix,suffix,delimiter)	convert decimal-based encoded text to plain text
item3	EnDe.DE.oct(type,mode,src,prefix,suffix,delimiter)	oct(type,mode,src,prefix,suffix,delimiter)	convert octal-based encoded text to plain text
item3	EnDe.DE.bin(type,mode,src,prefix,suffix,delimiter)	bin(type,mode,src,prefix,suffix,delimiter)	convert binary-based encoded text to plain text
item3	EnDe.DE.bcd(_n1_,_n2_,src,_n5_,_n6_,delimiter)	bcd(_n1_,_n2_,src,_n5_,_n6_,delimiter)	convert BCD coded numbers to digits
item3	EnDe.DE.aiken(_n1_,_n2_,src,_n5_,_n6_,delimiter)	aiken(_n1_,_n2_,src,_n5_,_n6_,delimiter)	convert Aiken coded numbers in text to digits
item3	EnDe.DE.stibitz(_n1_,_n2_,src,_n5_,_n6_,delimiter)	stibitz(_n1_,_n2_,src,_n5_,_n6_,delimiter)	convert Stibitz coded numbers in text to digits
item3	EnDe.DE.cp(src)	cp(src)	convert all characters from Windows CP-1252 to unicode base characters
item3	EnDe.DE.dta(src)	dta(src)	convert all characters from DIN66003 to ASCII characters
item3	EnDe.DE.utf7(_n1_,_n2_,src,_n5_,_n6_,_n7_)	utf7(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert UTF-7 encoded text to plain text
item3	EnDe.DE.utf8(_n1_,_n2_,src,_n5_,_n6_,_n7_)	utf8(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert UTF-8 encoded text to plain text
item3	EnDe.DE.f2h(_n1_,_n2_,src,_n5_,_n6_,_n7_)	f2h(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert fullwidth Unicode to halfwidth Unicode characters; wrapper for EnDe.UCS.f2h()
item3	EnDe.DE.h2f(_n1_,_n2_,src,_n5_,_n6_,_n7_)	h2f(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert halfwidth Unicode to fullwidth Unicode characters; wrapper for EnDe.UCS.h2f()
item3	EnDe.DE.ncr(type,mode,src,prefix,suffix,delimiter)	ncr(type,mode,src,prefix,suffix,delimiter)	convert named HTML-Entity to plain text
item3	EnDe.DE.toCode(type,mode,src,prefix,suffix,delimiter)	toCode(type,mode,src,prefix,suffix,delimiter)	wrapper for EnDe.chr2code()
item3	EnDe.DE.fromCode(type,mode,src,prefix,suffix,delimiter)	fromCode(type,mode,src,prefix,suffix,delimiter)	wrapper for EnDe.code2chr()
item3	EnDe.DE.fromJava(type,mode,src,prefix,suffix,delimiter)	fromJava(type,mode,src,prefix,suffix,delimiter)	wrapper for EnDe.java2chr()
item3	EnDe.DE.xml(_n1_,_n2_,src,_n5_,_n6_,_n7_)	xml(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert XML encoded text to plain text
item3	EnDe.DE.esc(type,_n2_,src,_n5_,_n6_,_n7_)	esc(type,_n2_,src,_n5_,_n6_,_n7_)	convert enscaped text to plain text
item3	EnDe.DE.esc('escCSS',_n2_,src,_n5_,_n6_,_n7_)	esc('escCSS',_n2_,src,_n5_,_n6_,_n7_)	escCSS:  expect CSS hex numbered entities
item3	EnDe.DE.esc('escHTML',_n2_,src,_n5_,_n6_,_n7_)	esc('escHTML',_n2_,src,_n5_,_n6_,_n7_)	escHTML: expect HTML named Entities
item3	EnDe.DE.esc('escURL',_n2_,src,_n5_,_n6_,_n7_)	esc('escURL',_n2_,src,_n5_,_n6_,_n7_)	escURL:  expect URL encoding
item3	EnDe.DE.esc('escJS',_n2_,src,_n5_,_n6_,_n7_)	esc('escJS',_n2_,src,_n5_,_n6_,_n7_)	escJS:   expect JavaScript escaping
item3	EnDe.DE.esc('escSQL',_n2_,src,_n5_,_n6_,_n7_)	esc('escSQL',_n2_,src,_n5_,_n6_,_n7_)	escSQL:  convert '' to '
item3	EnDe.DE.esc('escXML',_n2_,src,_n5_,_n6_,_n7_)	esc('escXML',_n2_,src,_n5_,_n6_,_n7_)	escXML:  expect XML named Entities
item3	EnDe.DE.esc('escQuote',_n2_,src,_n5_,_n6_,_n7_)	esc('escQuote',_n2_,src,_n5_,_n6_,_n7_)	escQuote: convert \' and \" to ' "
item3	EnDe.DE.esc('escJava',_n2_,src,_n5_,_n6_,_n7_)	esc('escJava',_n2_,src,_n5_,_n6_,_n7_)	escJava: expect Java escaping
item3	EnDe.DE.uu(type,mode,src,prefix,suffix,delimiter)	uu(type,mode,src,prefix,suffix,delimiter)	convert UUencode text to plain text; delimiter is the padding character
item3	EnDe.DE.uu('hist',mode,src,prefix,suffix,delimiter)	uu('hist',mode,src,prefix,suffix,delimiter)	hist:
item3	EnDe.DE.uu('raw',mode,src,prefix,suffix,delimiter)	uu('raw',mode,src,prefix,suffix,delimiter)	raw:
item3	EnDe.DE.uu('user',mode,src,prefix,suffix,delimiter)	uu('user',mode,src,prefix,suffix,delimiter)	user:
item3	EnDe.DE.qp(_n1_,mode,src,_n5_,_n6_,_n7_)	qp(_n1_,mode,src,_n5_,_n6_,_n7_)	convert quoted printable text to plain text
item3	EnDe.DE.idn(type,_n3_,src,_n5_,suffix,_n7_)	idn(type,_n3_,src,_n5_,suffix,_n7_)	convert punycode or IDNA-punycode to string
item3	EnDe.DE.idn('IDN',_n3_,src,_n5_,suffix,_n7_)	idn('IDN',_n3_,src,_n5_,suffix,_n7_)	IDN:  convert URI only
item3	EnDe.DE.idn('PNY',_n3_,src,_n5_,suffix,_n7_)	idn('PNY',_n3_,src,_n5_,suffix,_n7_)	PNY:  convert FQDN only (strip off leading schema and trailing search parameter)
item3	EnDe.DE.idn('PNY_',_n3_,src,_n5_,suffix,_n7_)	idn('PNY_',_n3_,src,_n5_,suffix,_n7_)	PNY_: convert complete string
item3	EnDe.DE.idn('IDN_',_n3_,src,_n5_,suffix,_n7_)	idn('IDN_',_n3_,src,_n5_,suffix,_n7_)	IDN_: convert complete string
item3	EnDe.DE.a2e(_n1_,_n2_,src,_n5_,_n6_,_n7_)	a2e(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert ASCII to EBCDIC characters
item3	EnDe.DE.e2a(_n1_,_n2_,src,_n5_,_n6_,_n7_)	e2a(_n1_,_n2_,src,_n5_,_n6_,_n7_)	convert EBCDIC to ASCII characters
item3	EnDe.DE.rot(_n1_,_n2_,src,_n5_,key,_n7_)	rot(_n1_,_n2_,src,_n5_,key,_n7_)	convert string to rot-N-encoded text (aka Caesar encoding)
item3	EnDe.DE.sos(type,mode,src,prefix,suffix,delimiter)	sos(type,mode,src,prefix,suffix,delimiter)	convert morse characters to plain text
item3	EnDe.DE.baudot(type,mode,src,prefix,suffix,delimiter)	baudot(type,mode,src,prefix,suffix,delimiter)	convert Baudot characters to plain text
item3	EnDe.DE.dmp(type,mode,uppercase,src,prefix,suffix,delimiter)	dmp(type,mode,uppercase,src,prefix,suffix,delimiter)	convert from traditional xdump or od style: (hex values left only)
item3	EnDe.DE.dmp('hex',mode,uppercase,src,prefix,suffix,delimiter)	dmp('hex',mode,uppercase,src,prefix,suffix,delimiter)	hex: 'xdump' style input (space seperated hex values left, strings right)
item3	EnDe.DE.dmp('ODx',mode,uppercase,src,prefix,suffix,delimiter)	dmp('ODx',mode,uppercase,src,prefix,suffix,delimiter)	ODx: 'od -x' style input (count, 2- or 4-byte hex values)
item3	EnDe.DE.dmp('xDO',mode,uppercase,src,prefix,suffix,delimiter)	dmp('xDO',mode,uppercase,src,prefix,suffix,delimiter)	xDO: 'od -x' style input (count, 4-byte hex values little endian)
item3	EnDe.DE.blowfish(type,mode,uppercase,src,prefix,key,delimiter)	blowfish(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for blowfish()
item3	EnDe.DE.aes(type,mode,uppercase,src,prefix,key,delimiter)	aes(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for AES(); uppercase parameter is escCtl (see aes.js)
item3	EnDe.DE.tea(type,mode,uppercase,src,prefix,key,delimiter)	tea(type,mode,uppercase,src,prefix,key,delimiter)	decrypt a string using the Block Tiny Encryption Algorithm
item3	EnDe.DE.yenc(type,mode,uppercase,src,prefix,key,delimiter)	yenc(type,mode,uppercase,src,prefix,key,delimiter)	yDecode
item3	EnDe.DE.fuzzy(type,mode,src,prefix,suffix,delimiter)	fuzzy(type,mode,src,prefix,suffix,delimiter)	fuzzy decoding ..
item3	EnDe.DE.fuzzy('fuzOCTsq',mode,src,prefix,suffix,delimiter)	fuzzy('fuzOCTsq',mode,src,prefix,suffix,delimiter)	fuzOCTsq: decode octal inside single quotes
item3	EnDe.DE.fuzzy('fuzOCTdq',mode,src,prefix,suffix,delimiter)	fuzzy('fuzOCTdq',mode,src,prefix,suffix,delimiter)	fuzOCTdq: decode octal inside double quotes
item3	EnDe.DE.fuzzy('fuzHEXsq',mode,src,prefix,suffix,delimiter)	fuzzy('fuzHEXsq',mode,src,prefix,suffix,delimiter)	fuzHEXsq: decode hex inside single quotes
item3	EnDe.DE.fuzzy('fuzHEXdq',mode,src,prefix,suffix,delimiter)	fuzzy('fuzHEXdq',mode,src,prefix,suffix,delimiter)	fuzHEXdq: decode hex inside double quotes
item3	EnDe.DE.fuzzy('fuzUCSsq',mode,src,prefix,suffix,delimiter)	fuzzy('fuzUCSsq',mode,src,prefix,suffix,delimiter)	fuzUCSsq: decode Unicode inside single quotes
item3	EnDe.DE.fuzzy('fuzUCSdq',mode,src,prefix,suffix,delimiter)	fuzzy('fuzUCSdq',mode,src,prefix,suffix,delimiter)	fuzUCSdq: decode Unicode inside double quotes
item3	EnDe.DE.fuzzy('...',mode,src,prefix,suffix,delimiter)	fuzzy('...',mode,src,prefix,suffix,delimiter)	...
item3	EnDe.DE.guess(_n1_,mode,uppercase,src,prefix,suffix,delimiter)	guess(_n1_,mode,uppercase,src,prefix,suffix,delimiter)	**depricated**
item3	EnDe.DE.dispatch(type,mode,uppercase,src,prefix,suffix,delimiter)	dispatch(type,mode,uppercase,src,prefix,suffix,delimiter)	dispatcher for decoding functions


group	EnDe.MD5	EnDe.MD5	EnDe.MD5
item3	EnDe.MD5.hex_md5(s)	hex_md5(s)	
item3	EnDe.MD5.b64_md5(s)	b64_md5(s)	
item3	EnDe.MD5.str_md5(s)	str_md5(s)	
item3	EnDe.MD5.hex_hmac_md5(key, s)	hex_hmac_md5(key, s)	
item3	EnDe.MD5.b64_hmac_md5(key, s)	b64_hmac_md5(key, s)	
item3	EnDe.MD5.str_hmac_md5(key, s)	str_hmac_md5(key, s)	


group	EnDe.EN	EnDe.EN	EnDe.EN
item3	EnDe.EN.chr(_n1_,_n2_,_n3_,src,prefix,suffix,delimiter)	chr(_n1_,_n2_,_n3_,src,prefix,suffix,delimiter)	convert string to list of characters with prefix, delimiter and suffix
item3	EnDe.EN.hex(type,mode,uppercase,src,prefix,suffix,delimiter)	hex(type,mode,uppercase,src,prefix,suffix,delimiter)	convert plain text to hex encoded text
item3	EnDe.EN.hex('null',mode,uppercase,src,prefix,suffix,delimiter)	hex('null',mode,uppercase,src,prefix,suffix,delimiter)	null: converted hex value without prefix and no padding
item3	EnDe.EN.hex('qp2',mode,uppercase,src,prefix,suffix,delimiter)	hex('qp2',mode,uppercase,src,prefix,suffix,delimiter)	qp2:  converted hex value prefixed with =
item3	EnDe.EN.hex('hex0',mode,uppercase,src,prefix,suffix,delimiter)	hex('hex0',mode,uppercase,src,prefix,suffix,delimiter)	hex0: converted hex value (no padding)
item3	EnDe.EN.hex('hex1',mode,uppercase,src,prefix,suffix,delimiter)	hex('hex1',mode,uppercase,src,prefix,suffix,delimiter)	hex1: converted hex value (no padding)
item3	EnDe.EN.hex('2',mode,uppercase,src,prefix,suffix,delimiter)	hex('2',mode,uppercase,src,prefix,suffix,delimiter)	2:    converted 2-digit hex
item3	EnDe.EN.hex('3',mode,uppercase,src,prefix,suffix,delimiter)	hex('3',mode,uppercase,src,prefix,suffix,delimiter)	3:    converted 3-digit hex
item3	EnDe.EN.hex('n',mode,uppercase,src,prefix,suffix,delimiter)	hex('n',mode,uppercase,src,prefix,suffix,delimiter)	n:    converted n-digit hex
item3	EnDe.EN.hex('url2',mode,uppercase,src,prefix,suffix,delimiter)	hex('url2',mode,uppercase,src,prefix,suffix,delimiter)	url2: converted hex value prefixed with %
item3	EnDe.EN.hex('url3',mode,uppercase,src,prefix,suffix,delimiter)	hex('url3',mode,uppercase,src,prefix,suffix,delimiter)	url3: converted hex value prefixed with %0
item3	EnDe.EN.hex('url4',mode,uppercase,src,prefix,suffix,delimiter)	hex('url4',mode,uppercase,src,prefix,suffix,delimiter)	url4: converted hex value prefixed with %00
item3	EnDe.EN.hex('urlc',mode,uppercase,src,prefix,suffix,delimiter)	hex('urlc',mode,uppercase,src,prefix,suffix,delimiter)	urlc: set high bit in hex encoding (results in %c0 prefix)
item3	EnDe.EN.hex('ncr2',mode,uppercase,src,prefix,suffix,delimiter)	hex('ncr2',mode,uppercase,src,prefix,suffix,delimiter)	ncr2: converted hex value prefixed with &#x
item3	EnDe.EN.hex('ncr4',mode,uppercase,src,prefix,suffix,delimiter)	hex('ncr4',mode,uppercase,src,prefix,suffix,delimiter)	ncr4: converted hex value prefixed with &#x00
item3	EnDe.EN.hex('nibbles',mode,uppercase,src,prefix,suffix,delimiter)	hex('nibbles',mode,uppercase,src,prefix,suffix,delimiter)	nibbles: convert hex value to its nibble hex values
item3	EnDe.EN.hex('nibble1',mode,uppercase,src,prefix,suffix,delimiter)	hex('nibble1',mode,uppercase,src,prefix,suffix,delimiter)	nibble1: convert hex value to its first nibble hex value
item3	EnDe.EN.hex('nibble2',mode,uppercase,src,prefix,suffix,delimiter)	hex('nibble2',mode,uppercase,src,prefix,suffix,delimiter)	nibble2: convert hex value to its second nibble hex value
item3	EnDe.EN.url(type,mode,uppercase,src,prefix,suffix,delimiter)	url(type,mode,uppercase,src,prefix,suffix,delimiter)	convert plain text to URL encoded text
item3	EnDe.EN.url('null',mode,uppercase,src,prefix,suffix,delimiter)	url('null',mode,uppercase,src,prefix,suffix,delimiter)	null: converted URL (hex) value without prefix and no padding
item3	EnDe.EN.url('qp2',mode,uppercase,src,prefix,suffix,delimiter)	url('qp2',mode,uppercase,src,prefix,suffix,delimiter)	qp2:  converted URL (hex) value prefixed with =
item3	EnDe.EN.url('hex0',mode,uppercase,src,prefix,suffix,delimiter)	url('hex0',mode,uppercase,src,prefix,suffix,delimiter)	hex0: converted URL (hex) value (no padding)
item3	EnDe.EN.url('hex1',mode,uppercase,src,prefix,suffix,delimiter)	url('hex1',mode,uppercase,src,prefix,suffix,delimiter)	hex1: converted URL (hex) value (no padding)
item3	EnDe.EN.url('3',mode,uppercase,src,prefix,suffix,delimiter)	url('3',mode,uppercase,src,prefix,suffix,delimiter)	3:    converted 3-digit URL (hex)
item3	EnDe.EN.url('n',mode,uppercase,src,prefix,suffix,delimiter)	url('n',mode,uppercase,src,prefix,suffix,delimiter)	n:    converted n-digit URL (hex)
item3	EnDe.EN.url('url2',mode,uppercase,src,prefix,suffix,delimiter)	url('url2',mode,uppercase,src,prefix,suffix,delimiter)	url2: converted URL (hex) value prefixed with %
item3	EnDe.EN.url('url3',mode,uppercase,src,prefix,suffix,delimiter)	url('url3',mode,uppercase,src,prefix,suffix,delimiter)	url3: converted URL (hex) value prefixed with %0
item3	EnDe.EN.url('url4',mode,uppercase,src,prefix,suffix,delimiter)	url('url4',mode,uppercase,src,prefix,suffix,delimiter)	url4: converted URL (hex) value prefixed with %00
item3	EnDe.EN.url('urlc',mode,uppercase,src,prefix,suffix,delimiter)	url('urlc',mode,uppercase,src,prefix,suffix,delimiter)	urlc: set high bit in URL (hex) encoding (results in %c0 prefix)
item3	EnDe.EN.url('ncr2',mode,uppercase,src,prefix,suffix,delimiter)	url('ncr2',mode,uppercase,src,prefix,suffix,delimiter)	ncr2: converted URL (hex) value prefixed with &#x
item3	EnDe.EN.url('ncr4',mode,uppercase,src,prefix,suffix,delimiter)	url('ncr4',mode,uppercase,src,prefix,suffix,delimiter)	ncr4: converted URL (hex) value prefixed with &#x00
item3	EnDe.EN.url('ucs',mode,uppercase,src,prefix,suffix,delimiter)	url('ucs',mode,uppercase,src,prefix,suffix,delimiter)	ucs:  converted URL (hex) value prefixed with % (hex values for Unicode character)
item3	EnDe.EN.url('utf8',mode,uppercase,src,prefix,suffix,delimiter)	url('utf8',mode,uppercase,src,prefix,suffix,delimiter)	utf8: converted URL (hex) value prefixed with % (hex values for UTF-8 character)
item3	EnDe.EN.url('utf8c',mode,uppercase,src,prefix,suffix,delimiter)	url('utf8c',mode,uppercase,src,prefix,suffix,delimiter)	utf8c: set high bit in URL (hex) encoding (results in %c0 prefix)
item3	EnDe.EN.url('nibbles',mode,uppercase,src,prefix,suffix,delimiter)	url('nibbles',mode,uppercase,src,prefix,suffix,delimiter)	nibbles: convert URL (hex) value to its nibble hex values
item3	EnDe.EN.url('nibble1',mode,uppercase,src,prefix,suffix,delimiter)	url('nibble1',mode,uppercase,src,prefix,suffix,delimiter)	nibble1: convert URL (hex) value to its first nibble hex value
item3	EnDe.EN.url('nibble2',mode,uppercase,src,prefix,suffix,delimiter)	url('nibble2',mode,uppercase,src,prefix,suffix,delimiter)	nibble2: convert URL (hex) value to its second nibble hex value
item3	EnDe.EN.dez(type,mode,_n3_,src,prefix,suffix,delimiter)	dez(type,mode,_n3_,src,prefix,suffix,delimiter)	convert plain text to decimal encoded text
item3	EnDe.EN.dez('null',mode,_n3_,src,prefix,suffix,delimiter)	dez('null',mode,_n3_,src,prefix,suffix,delimiter)	null: converted decimal value with variable length (2-3 digits)
item3	EnDe.EN.dez('ncr2',mode,_n3_,src,prefix,suffix,delimiter)	dez('ncr2',mode,_n3_,src,prefix,suffix,delimiter)	ncr2: converted decimal value prefixed with &#x
item3	EnDe.EN.dez('3',mode,_n3_,src,prefix,suffix,delimiter)	dez('3',mode,_n3_,src,prefix,suffix,delimiter)	3:    converted 3-digit decimal
item3	EnDe.EN.dez('n',mode,_n3_,src,prefix,suffix,delimiter)	dez('n',mode,_n3_,src,prefix,suffix,delimiter)	n:    converted n-digit decimal
item3	EnDe.EN.oct(type,mode,uppercase,src,prefix,suffix,delimiter)	oct(type,mode,uppercase,src,prefix,suffix,delimiter)	convert plain text to octal encoded text
item3	EnDe.EN.oct('null',mode,uppercase,src,prefix,suffix,delimiter)	oct('null',mode,uppercase,src,prefix,suffix,delimiter)	null: converted octal value with variable length (2-3 digits)
item3	EnDe.EN.oct('3',mode,uppercase,src,prefix,suffix,delimiter)	oct('3',mode,uppercase,src,prefix,suffix,delimiter)	3:    converted 3-digit octal
item3	EnDe.EN.oct('n',mode,uppercase,src,prefix,suffix,delimiter)	oct('n',mode,uppercase,src,prefix,suffix,delimiter)	n:    converted n-digit octal
item3	EnDe.EN.bin(type,mode,_n3_,src,prefix,suffix,delimiter)	bin(type,mode,_n3_,src,prefix,suffix,delimiter)	convert string to n-bit binary string
item3	EnDe.EN.bin('6',mode,_n3_,src,prefix,suffix,delimiter)	bin('6',mode,_n3_,src,prefix,suffix,delimiter)	6:    converted 6-digit binary
item3	EnDe.EN.bin('7',mode,_n3_,src,prefix,suffix,delimiter)	bin('7',mode,_n3_,src,prefix,suffix,delimiter)	7:    converted 7-digit binary
item3	EnDe.EN.bin('8',mode,_n3_,src,prefix,suffix,delimiter)	bin('8',mode,_n3_,src,prefix,suffix,delimiter)	8:    converted 8-digit binary
item3	EnDe.EN.bcd(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	bcd(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert numbers in text to BCD coded numbers
item3	EnDe.EN.aiken(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	aiken(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert numbers in text to Aiken coded numbers
item3	EnDe.EN.stibitz(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	stibitz(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert numbers in text to Stibitz coded numbers
item3	EnDe.EN.cp(src)	cp(src)	convert all characters from unicode base to Windows CP-1252 characters
item3	EnDe.EN.dta(src)	dta(src)	convert all characters from ASCII to DIN66003 characters
item3	EnDe.EN.ucs(type,mode,uppercase,src,prefix,suffix,delimiter)	ucs(type,mode,uppercase,src,prefix,suffix,delimiter)	convert plain text to Unicode UCS-2 encoded text
item3	EnDe.EN.ucs('null',mode,uppercase,src,prefix,suffix,delimiter)	ucs('null',mode,uppercase,src,prefix,suffix,delimiter)	null: converted Unicode without prefix
item3	EnDe.EN.ucs('url4',mode,uppercase,src,prefix,suffix,delimiter)	ucs('url4',mode,uppercase,src,prefix,suffix,delimiter)	url4: converted Unicode prefixed %u
item3	EnDe.EN.ucs('ucs4',mode,uppercase,src,prefix,suffix,delimiter)	ucs('ucs4',mode,uppercase,src,prefix,suffix,delimiter)	ucs4: converted Unicode prefixed \u
item3	EnDe.EN.ucs('IE4',mode,uppercase,src,prefix,suffix,delimiter)	ucs('IE4',mode,uppercase,src,prefix,suffix,delimiter)	IE4:  converted Unicode prefixed \u
item3	EnDe.EN.utf7(type,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf7(type,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert plain text to UTF-7 encoded text
item3	EnDe.EN.utf7('null',_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf7('null',_n2_,_n3_,src,_n5_,_n6_,_n7_)	null: convert UTF-7 unsave characters only
item3	EnDe.EN.utf7('all',_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf7('all',_n2_,_n3_,src,_n5_,_n6_,_n7_)	all:  convert all characters
item3	EnDe.EN.utf(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	dispatcher/wrapper for EnDe.UCS.* calls
item3	EnDe.EN.utf16le(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf16le(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.UCS.utf16le
item3	EnDe.EN.utf16be(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf16be(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.UCS.utf16be
item3	EnDe.EN.utf16(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf16(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.UCS.utf16be
item3	EnDe.EN.utf32le(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf32le(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.UCS.utf32le
item3	EnDe.EN.utf32be(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf32be(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.UCS.utf32be
item3	EnDe.EN.utf8bom(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf8bom(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert plain text to UTF-8 encoded text with BOM
item3	EnDe.EN.utf8(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	utf8(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert plain text to UTF-8 encoded text
item3	EnDe.EN.f2h(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	f2h(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert fullwidth Unicode to halfwidth Unicode characters; wrapper for EnDe.UCS.f2h()
item3	EnDe.EN.h2f(type,mode,uppercase,src,_n5_,_n6_,_n7_)	h2f(type,mode,uppercase,src,_n5_,_n6_,_n7_)	convert halfwidth Unicode to fullwidth Unicode characters (UTF-16, 2 bytes)
item3	EnDe.EN.h2f('null',mode,uppercase,src,_n5_,_n6_,_n7_)	h2f('null',mode,uppercase,src,_n5_,_n6_,_n7_)	null: converted fullwidth Unicode characters are UTF-16, 2 bytes
item3	EnDe.EN.h2f('utf8',mode,uppercase,src,_n5_,_n6_,_n7_)	h2f('utf8',mode,uppercase,src,_n5_,_n6_,_n7_)	utf8: converted fullwidth Unicode characters are UTF-8, 3 bytes
item3	EnDe.EN.ncr(type,mode,uppercase,src,prefix,suffix,delimiter)	ncr(type,mode,uppercase,src,prefix,suffix,delimiter)	convert plain text to named/numbered HTML-Entity
item3	EnDe.EN.ncr('null',mode,uppercase,src,prefix,suffix,delimiter)	ncr('null',mode,uppercase,src,prefix,suffix,delimiter)	null: assume standard character map; using HTML named Entities
item3	EnDe.EN.ncr('name',mode,uppercase,src,prefix,suffix,delimiter)	ncr('name',mode,uppercase,src,prefix,suffix,delimiter)	name: assume standard character map; using HTML named Entities
item3	EnDe.EN.ncr('css',mode,uppercase,src,prefix,suffix,delimiter)	ncr('css',mode,uppercase,src,prefix,suffix,delimiter)	css:  assume standard character map; using HTML hex numberd Entities
item3	EnDe.EN.ncr('dez',mode,uppercase,src,prefix,suffix,delimiter)	ncr('dez',mode,uppercase,src,prefix,suffix,delimiter)	dez:  assume standard character map; using HTML decimal numberd Entities
item3	EnDe.EN.ncr('winf',mode,uppercase,src,prefix,suffix,delimiter)	ncr('winf',mode,uppercase,src,prefix,suffix,delimiter)	winf: assume force convertion as from Windows CP-1252 character map
item3	EnDe.EN.ncr('win',mode,uppercase,src,prefix,suffix,delimiter)	ncr('win',mode,uppercase,src,prefix,suffix,delimiter)	win:  assume Windows CP-1252 character map
item3	EnDe.EN.toCode(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	toCode(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.chr2code()
item3	EnDe.EN.fromCode(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	fromCode(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.code2chr()
item3	EnDe.EN.fromJava(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	fromJava(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	wrapper for EnDe.java2chr()
item3	EnDe.EN.xml(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	xml(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert plain text to XML-escaped text
item3	EnDe.EN.esc(type,_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc(type,_n2_,uppercase,src,_n5_,_n6_,_n7_)	convert plain text to escaped text
item3	EnDe.EN.esc('escCSS',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escCSS',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escCSS:  use CSS hex numbered entities
item3	EnDe.EN.esc('escHTML',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escHTML',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escHTML: use HTML named Entities
item3	EnDe.EN.esc('escURL',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escURL',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escURL:  use URL encoding
item3	EnDe.EN.esc('escJS',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escJS',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escJS:   use \-escaped \ and " and '
item3	EnDe.EN.esc('escSQL',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escSQL',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escSQL:  use '' for '
item3	EnDe.EN.esc('escQuote',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escQuote',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escQuote:  use URL encoding
item3	EnDe.EN.esc('escXML',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escXML',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escXML:  use XML named Entities
item3	EnDe.EN.esc('escJava',_n2_,uppercase,src,_n5_,_n6_,_n7_)	esc('escJava',_n2_,uppercase,src,_n5_,_n6_,_n7_)	escJava: use \-escaped " and \uHHHH for other non-US-ASCII
item3	EnDe.EN.uu_DoesNotWork(src)	uu_DoesNotWork(src)	**trash**
item3	EnDe.EN.uu(type,mode,_n3_,src,prefix,suffix,delimiter)	uu(type,mode,_n3_,src,prefix,suffix,delimiter)	convert plain text to UUencode text; delimiter is the padding character
item3	EnDe.EN.uu('null',mode,_n3_,src,prefix,suffix,delimiter)	uu('null',mode,_n3_,src,prefix,suffix,delimiter)	null:
item3	EnDe.EN.uu('raw',mode,_n3_,src,prefix,suffix,delimiter)	uu('raw',mode,_n3_,src,prefix,suffix,delimiter)	raw:  convert UUencode without prefix and suffix
item3	EnDe.EN.uu('all',mode,_n3_,src,prefix,suffix,delimiter)	uu('all',mode,_n3_,src,prefix,suffix,delimiter)	all:  convert all characters
item3	EnDe.EN.qp(type,mode,_n3_,src,_n5_,_n6_,_n7_)	qp(type,mode,_n3_,src,_n5_,_n6_,_n7_)	convert plain text to quoted printable text
item3	EnDe.EN.qp('null',mode,_n3_,src,_n5_,_n6_,_n7_)	qp('null',mode,_n3_,src,_n5_,_n6_,_n7_)	null: convert all characters
item3	EnDe.EN.qp('raw',mode,_n3_,src,_n5_,_n6_,_n7_)	qp('raw',mode,_n3_,src,_n5_,_n6_,_n7_)	raw:  do not convert \n and \r characters
item3	EnDe.EN.idn(type,_n2_,_n3_,src,_n5_,suffix,_n7_)	idn(type,_n2_,_n3_,src,_n5_,suffix,_n7_)	convert string to punycode or IDNA-punycode
item3	EnDe.EN.idn('IDN',_n2_,_n3_,src,_n5_,suffix,_n7_)	idn('IDN',_n2_,_n3_,src,_n5_,suffix,_n7_)	IDN:  convert URI only
item3	EnDe.EN.idn('PNY',_n2_,_n3_,src,_n5_,suffix,_n7_)	idn('PNY',_n2_,_n3_,src,_n5_,suffix,_n7_)	PNY:  convert FQDN only (strip off leading schema and trailing search parameter)
item3	EnDe.EN.idn('PNY_',_n2_,_n3_,src,_n5_,suffix,_n7_)	idn('PNY_',_n2_,_n3_,src,_n5_,suffix,_n7_)	PNY_: convert complete string
item3	EnDe.EN.idn('IDN_',_n2_,_n3_,src,_n5_,suffix,_n7_)	idn('IDN_',_n2_,_n3_,src,_n5_,suffix,_n7_)	IDN_: convert complete string
item3	EnDe.EN.a2e(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	a2e(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert ASCII to EBCDIC characters
item3	EnDe.EN.e2a(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	e2a(_n1_,_n2_,_n3_,src,_n5_,_n6_,_n7_)	convert EBCDIC to ASCII characters
item3	EnDe.EN.rot(_n1_,_n2_,_n3_,src,_n5_,key,_n7_)	rot(_n1_,_n2_,_n3_,src,_n5_,key,_n7_)	convert string to rot-N-encoded text (aka Caesar encoding)
item3	EnDe.EN.sos(_n1_,mode,_n3_,src,prefix,suffix,delimiter)	sos(_n1_,mode,_n3_,src,prefix,suffix,delimiter)	convert to morse characters
item3	EnDe.EN.baudot(_n1_,mode,_n3_,src,_n5_,_n6_,delimiter)	baudot(_n1_,mode,_n3_,src,_n5_,_n6_,delimiter)	convert to Baudot characters
item3	EnDe.EN.braille(type,mode,_n3_,src,prefix,_n6_,delimiter)	braille(type,mode,_n3_,src,prefix,_n6_,delimiter)	convert to Braille characters
item3	EnDe.EN.braille('ASCIIBr',mode,_n3_,src,prefix,_n6_,delimiter)	braille('ASCIIBr',mode,_n3_,src,prefix,_n6_,delimiter)	ASCIIBr:  use ASCII-Braille symbols
item3	EnDe.EN.braille('dotBr',mode,_n3_,src,prefix,_n6_,delimiter)	braille('dotBr',mode,_n3_,src,prefix,_n6_,delimiter)	dotBr:    use dot-Braille symbols
item3	EnDe.EN.braille('NumBr',mode,_n3_,src,prefix,_n6_,delimiter)	braille('NumBr',mode,_n3_,src,prefix,_n6_,delimiter)	NumBr:    use number symbols
item3	EnDe.EN.braille('DadaUrka',mode,_n3_,src,prefix,_n6_,delimiter)	braille('DadaUrka',mode,_n3_,src,prefix,_n6_,delimiter)	DadaUrka: use Dada Urka symbols
item3	EnDe.EN.blade(type,mode,_n3_,src,_n5_,_n6_,_n7_)	blade(type,mode,_n3_,src,_n5_,_n6_,_n7_)	convert digits to Blade (ASCII) symbols
item3	EnDe.EN.dmp(type,mode,uppercase,src,prefix,suffix,delimiter)	dmp(type,mode,uppercase,src,prefix,suffix,delimiter)	convert to traditional xdump style: hex values left, characters right
item3	EnDe.EN.odx(type,mode,uppercase,src,prefix,suffix,delimiter)	odx(type,mode,uppercase,src,prefix,suffix,delimiter)	convert to traditional "od -x" style: double hex values with space as delimiter
item3	EnDe.EN.odx('ODx',mode,uppercase,src,prefix,suffix,delimiter)	odx('ODx',mode,uppercase,src,prefix,suffix,delimiter)	ODx: od -x style big endian
item3	EnDe.EN.odx('xOD',mode,uppercase,src,prefix,suffix,delimiter)	odx('xOD',mode,uppercase,src,prefix,suffix,delimiter)	xOD: od -x style little endian
item3	EnDe.EN.crc(type,mode,uppercase,src,iv,mask,polynom)	crc(type,mode,uppercase,src,iv,mask,polynom)	wrapper for CRC functions
item3	EnDe.EN.md4(type,mode,uppercase,src,prefix,key,delimiter)	md4(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for str_md4()
item3	EnDe.EN.md5(type,mode,uppercase,src,prefix,key,delimiter)	md5(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for str_md5()
item3	EnDe.EN.sha(type,mode,uppercase,src,prefix,key,delimiter)	sha(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for sha1()
item3	EnDe.EN.sha256(type,mode,uppercase,src,prefix,key,delimiter)	sha256(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for sha2()
item3	EnDe.EN.sha384(type,mode,uppercase,src,prefix,key,delimiter)	sha384(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for sha384()
item3	EnDe.EN.sha512(type,mode,uppercase,src,prefix,key,delimiter)	sha512(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for sha512()
item3	EnDe.EN.blowfish(type,mode,uppercase,src,prefix,key,delimiter)	blowfish(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for blowfish()
item3	EnDe.EN.aes(type,mode,uppercase,src,prefix,key,delimiter)	aes(type,mode,uppercase,src,prefix,key,delimiter)	wrapper for AES(); uppercase parameter is escCtl (see aes.js)
item3	EnDe.EN.rmd(type,mode,uppercase,src,_n5_,key,delimiter)	rmd(type,mode,uppercase,src,_n5_,key,delimiter)	wrapper for gen_otp_rmd160(); delimiter is the number of iterations
item3	EnDe.EN.tea(type,mode,uppercase,src,prefix,key,delimiter)	tea(type,mode,uppercase,src,prefix,key,delimiter)	encrypt a string using the Block Tiny Encryption Algorithm
item3	EnDe.EN.yenc(type,mode,uppercase,src,prefix,key,delimiter)	yenc(type,mode,uppercase,src,prefix,key,delimiter)	yEncode
item3	EnDe.EN.rsaz(type,mode,uppercase,src,prefix,key,delimiter)	rsaz(type,mode,uppercase,src,prefix,key,delimiter)	**not yet implemented**
item3	EnDe.EN.guess(_n1_,mode,uppercase,src,prefix,suffix,delimiter)	guess(_n1_,mode,uppercase,src,prefix,suffix,delimiter)	**depricated**
item3	EnDe.EN.dispatch(type,mode,uppercase,src,prefix,suffix,delimiter)	dispatch(type,mode,uppercase,src,prefix,suffix,delimiter)	dispatcher for encoding functions


group	EnDe.UCS	EnDe.UCS	EnDe.UCS
item3	EnDe.UCS.isUCS(src)	isUCS(src)	return true if charcter is valid code point; src is a single character
item3	EnDe.UCS.isUTF7(src)	isUTF7(src)	return true if charcter is UTF-7 character; src is a single character
item3	EnDe.UCS.isBOM(type,src)	isBOM(type,src)	dispatcher to check for BOM
item3	EnDe.UCS.isBOM('UTF32BE',src)	isBOM('UTF32BE',src)	UTF32BE: return true for UTF32BE BOM
item3	EnDe.UCS.isBOM('UTF32LE',src)	isBOM('UTF32LE',src)	UTF32LE: return true for UTF32LE BOM
item3	EnDe.UCS.isBOM('UTF16BE',src)	isBOM('UTF16BE',src)	UTF16BE: return true for UTF16BE BOM
item3	EnDe.UCS.isBOM('UTF16LE',src)	isBOM('UTF16LE',src)	UTF16LE: return true for UTF16LE BOM
item3	EnDe.UCS.isBOM('UTF8',src)	isBOM('UTF8',src)	UTF8   : return true for UTF8 BOM
item3	EnDe.UCS.getBOM(type)	getBOM(type)	get (character) value for BOM
item3	EnDe.UCS.getBOM('UTF32BE')	getBOM('UTF32BE')	UTF32BE: return UTF32BE BOM bytes
item3	EnDe.UCS.getBOM('UTF32LE')	getBOM('UTF32LE')	UTF32LE: return UTF32LE BOM bytes
item3	EnDe.UCS.getBOM('UTF16BE')	getBOM('UTF16BE')	UTF16BE: return UTF16BE BOM bytes
item3	EnDe.UCS.getBOM('UTF16LE')	getBOM('UTF16LE')	UTF16LE: return UTF16LE BOM bytes
item3	EnDe.UCS.getBOM('UTF8')	getBOM('UTF8')	UTF8   : return UTF8 BOM bytes
item3	EnDe.UCS.str32BE(src)	str32BE(src)	return true if string starts with UTF-32 big-endian BOM
item3	EnDe.UCS.str32LE(src)	str32LE(src)	return true if string starts with UTF-32 little-endian BOM
item3	EnDe.UCS.str16BE(src)	str16BE(src)	return true if string starts with UTF-16 big-endian BOM
item3	EnDe.UCS.str16LE(src)	str16LE(src)	return true if string starts with UTF-16 little-endian BOM
item3	EnDe.UCS.strUTF8(src)	strUTF8(src)	return true if string starts with UTF-8 BOM
item3	EnDe.UCS.f2h(src)	f2h(src)	convert fullwidth Unicode to halfwidth Unicode characters
item3	EnDe.UCS.h2f(src)	h2f(src)	convert halfwidth Unicode to fullwidth Unicode characters
item3	EnDe.UCS.utf16le(src)	utf16le(src)	convert Unicode to UTF-16-LE characters
item3	EnDe.UCS.utf16be(src)	utf16be(src)	convert Unicode to UTF-16-BE characters
item3	EnDe.UCS.utf32le(src)	utf32le(src)	convert Unicode to UTF-32-LE characters


group	EnDe.AES.EN	EnDe.AES.EN	EnDe.AES.EN
item3	EnDe.AES.EN.aes(key,s,n)	aes(key,s,n)	
item3	EnDe.AES.EN.aes128(key, s)	aes128(key, s)	
item3	EnDe.AES.EN.aes192(key, s)	aes192(key, s)	
item3	EnDe.AES.EN.aes256(key, s)	aes256(key, s)	


group	EnDe.MD4	EnDe.MD4	EnDe.MD4
item3	EnDe.MD4.hex_md4(s)	hex_md4(s)	
item3	EnDe.MD4.b64_md4(s)	b64_md4(s)	
item3	EnDe.MD4.str_md4(s)	str_md4(s)	
item3	EnDe.MD4.hex_hmac_md4(key, s)	hex_hmac_md4(key, s)	
item3	EnDe.MD4.b64_hmac_md4(key, s)	b64_hmac_md4(key, s)	
item3	EnDe.MD4.str_hmac_md4(key, s)	str_hmac_md4(key, s)	


group	EnDe.Blowfish.EN	EnDe.Blowfish.EN	EnDe.Blowfish.EN
item3	EnDe.Blowfish.EN.blowfish(key,src)	blowfish(key,src)	


group	EnDe.HTTP.EN	EnDe.HTTP.EN	EnDe.HTTP.EN
item3	EnDe.HTTP.EN.header(dst)	header(dst)	build HTTP message header from dst (request or response)
item3	EnDe.HTTP.EN.body(dst)	body(dst)	build HTTP message body from dst (request or response)
item3	EnDe.HTTP.EN.set(_n1_,dst,src)	set(_n1_,dst,src)	build HTTP message from dst (request or response)	object for request methods


group	EnDe.IP.ipv6	EnDe.IP.ipv6	EnDe.IP.ipv6
item3	EnDe.IP.ipv6.ip2num(type,mode,uppercase,src,prefix,suffix,delimiter)	ip2num(type,mode,uppercase,src,prefix,suffix,delimiter)	**not yet implemented**


group	EnDe.SHA.sha2	EnDe.SHA.sha2	EnDe.SHA.sha2
item3	EnDe.SHA.sha2.S(x,n)	S(x,n)	
item3	EnDe.SHA.sha2.R(x,n)	R(x,n)	
item3	EnDe.SHA.sha2.Ch(x,y,z)	Ch(x,y,z)	
item3	EnDe.SHA.sha2.Maj(x,y,z)	Maj(x,y,z)	
item3	EnDe.SHA.sha2.sigma0256(x)	sigma0256(x)	
item3	EnDe.SHA.sha2.sigma1256(x)	sigma1256(x)	
item3	EnDe.SHA.sha2.gamma0256(x)	gamma0256(x)	
item3	EnDe.SHA.sha2.gamma1256(x)	gamma1256(x)	
item3	EnDe.SHA.sha2.sigma0512(x)	sigma0512(x)	
item3	EnDe.SHA.sha2.sigma1512(x)	sigma1512(x)	
item3	EnDe.SHA.sha2.gamma0512(x)	gamma0512(x)	
item3	EnDe.SHA.sha2.gamma1512(x)	gamma1512(x)	
item3	EnDe.SHA.sha2.core256(m, l)	core256(m, l)	
item3	EnDe.SHA.sha2.core512(m, l)	core512(m, l)	
item3	EnDe.SHA.sha2.test256()	test256()	
item3	EnDe.SHA.sha2.test()	test()	
item3	EnDe.SHA.sha2.hex(s)	hex(s)	
item3	EnDe.SHA.sha2.b64(s)	b64(s)	
item3	EnDe.SHA.sha2.str(s)	str(s)	


group	EnDe.HTTP	EnDe.HTTP	EnDe.HTTP
item3	EnDe.HTTP.str_index(idx,src)	str_index(idx,src)	return end of string starting at position idx 'til next occourance of character found at idx
item3	EnDe.HTTP.str_scope(idx,src)	str_scope(idx,src)	return end of string starting at position idx 'til next occourance proper closing bracket
item3	EnDe.HTTP.str_split(typ,src)	str_split(typ,src)	split src on separator typ, return array
item3	EnDe.HTTP.parse(typ,src)	parse(typ,src)	dispatcher for parsing QUERY string, POST data, etc., returns array
item3	EnDe.HTTP.parse('GET',src)	parse('GET',src)	GET:  assume search part of URL, split on &
item3	EnDe.HTTP.parse('POST',src)	parse('POST',src)	POST: assume POST request: split on &
item3	EnDe.HTTP.parse('mult',src)	parse('mult',src)	mult: assume POST request: split on boundary
item3	EnDe.HTTP.parse('GWT',src)	parse('GWT',src)	GWT:  assume POST request for GWT: split on |
item3	EnDe.HTTP.parse('XML',src)	parse('XML',src)	XML:  assume POST request as XML: split on tags insede outer scope
item3	EnDe.HTTP.parse('JSON',src)	parse('JSON',src)	JSON: assume POST request: split on ,
item3	EnDe.HTTP.parse('JSON-GWT',src)	parse('JSON-GWT',src)	JSON-GWT: assume response from GWT: split on , inside []
item3	EnDe.HTTP.dispatch(item,src,pos)	dispatch(item,src,pos)	wrapper for various HTTP text analysis; returns array with data
item3	EnDe.HTTP.NULL(src)	NULL(src)	


group	EnDe.Blowfish	EnDe.Blowfish	EnDe.Blowfish
item3	EnDe.Blowfish.encrypt(key,src)	encrypt(key,src)	
item3	EnDe.Blowfish.decrypt(key,src)	decrypt(key,src)	
item3	EnDe.Blowfish.escape(t)	escape(t)	
item3	EnDe.Blowfish.wordbyte0(w)	wordbyte0(w)	
item3	EnDe.Blowfish.wordbyte1(w)	wordbyte1(w)	
item3	EnDe.Blowfish.wordbyte2(w)	wordbyte2(w)	
item3	EnDe.Blowfish.wordbyte3(w)	wordbyte3(w)	
item3	EnDe.Blowfish.xor(w1,w2)	xor(w1,w2)	
item3	EnDe.Blowfish.unescape(t)	unescape(t)	


group	EnDe.B64	EnDe.B64	EnDe.B64
item3	EnDe.B64.isB16(src)	isB16(src)	return true if string consist of base16 characters only
item3	EnDe.B64.isB26(src)	isB26(src)	return true if string consist of base64 characters only
item3	EnDe.B64.isB34(src)	isB34(src)	return true if string consist of base34 characters only
item3	EnDe.B64.isB36(src)	isB36(src)	return true if string consist of base64 characters only
item3	EnDe.B64.isB52(src)	isB52(src)	return true if string consist of base64 characters only
item3	EnDe.B64.isB58(src)	isB58(src)	return true if string consist of base64 characters only
item3	EnDe.B64.isB62(src)	isB62(src)	return true if string consist of base64 characters only
item3	EnDe.B64.isB32c(src)	isB32c(src)	return true if string consist of Crockford base32 characters only
item3	EnDe.B64.isB32h(src)	isB32h(src)	return true if string consist of base32hex characters only
item3	EnDe.B64.isB32z(src)	isB32z(src)	return true if string consist of z-base32 characters only
item3	EnDe.B64.isB32(src)	isB32(src)	return true if string consist of base32 characters only
item3	EnDe.B64.isB64(src)	isB64(src)	return true if string consist of base64 characters only
item3	EnDe.B64.isU64(src)	isU64(src)	return true if string consist of url64 characters only
item3	EnDe.B64.init()	init()	
item3	EnDe.B64.is(type,src)	is(type,src)	return true if string is of given type


group	EnDe.RMD	EnDe.RMD	EnDe.RMD
item3	EnDe.RMD.word(key, src, i)	word(key, src, i)	
item3	EnDe.RMD.hex(key, src, i)	hex(key, src, i)	


group	EnDe.HTTP.req	EnDe.HTTP.req	EnDe.HTTP.req
item3	EnDe.HTTP.req.analyze(src)	analyze(src)	
item3	EnDe.HTTP.req.get(typ,src)	get(typ,src)	
item3	EnDe.HTTP.req.set(_n1_,src)	set(_n1_,src)	


group	EnDe.AES.DE	EnDe.AES.DE	EnDe.AES.DE
item3	EnDe.AES.DE.aes(key,s,n)	aes(key,s,n)	
item3	EnDe.AES.DE.aes128(key, s)	aes128(key, s)	
item3	EnDe.AES.DE.aes192(key, s)	aes192(key, s)	
item3	EnDe.AES.DE.aes265(key, s)	aes265(key, s)	


group	EnDe.HTTP.res	EnDe.HTTP.res	EnDe.HTTP.res
item3	EnDe.HTTP.res.analyze(src)	analyze(src)	
item3	EnDe.HTTP.res.get(typ,src)	get(typ,src)	
item3	EnDe.HTTP.res.set(_n1_,src)	set(_n1_,src)	


group	EnDe.SHA5	EnDe.SHA5	EnDe.SHA5
item3	EnDe.SHA5. hex_sha(string, variant)	 hex_sha(string, variant)	SHA-384, SHA-512 hash 


group	EnDe	EnDe	EnDe
item3	EnDe.set(typ,dst,src)	set(typ,dst,src)	build HTTP message from dst (request or response)
item3	EnDe.encode(type,mode,uppercase,src,prefix,suffix,delimiter)	encode(type,mode,uppercase,src,prefix,suffix,delimiter)	wrapper for EnDe.EN.dispatch()
item3	EnDe.decode(type,mode,uppercase,src,prefix,suffix,delimiter)	decode(type,mode,uppercase,src,prefix,suffix,delimiter)	wrapper for EnDe.DE.dispatch()
item3	EnDe.convert(type,mode,uppercase,src,prefix,suffix,delimiter)	convert(type,mode,uppercase,src,prefix,suffix,delimiter)	wrapper for EnDe.IP.dispatch()
item3	EnDe.alert(func,txt)	alert(func,txt)	internal wrapper for alert()
item3	EnDe.rex(src)	rex(src)	escape meta characters for RegExp
item3	EnDe.isBin(src)	isBin(src)	return true if string consist of 0 and 1 characters only
item3	EnDe.isOct(src)	isOct(src)	return true if string consist of octal characters only
item3	EnDe.isInt(src)	isInt(src)	return true if string consist of dezimal characters only
item3	EnDe.isHex(src)	isHex(src)	return true if string consist of hex characters only
item3	EnDe.isB16(src)	isB16(src)	return true if string consist of Base16 characters only
item3	EnDe.isB32(src)	isB32(src)	return true if string consist of Base32 characters only
item3	EnDe.isB64(src)	isB64(src)	return true if string consist of Base64 characters only
item3	EnDe.isU64(src)	isU64(src)	return true if string consist of Url64 characters only
item3	EnDe.isalnum(src)	isalnum(src)	return true if string consist of alpha-numeric characters only
item3	EnDe.isTyp(type,src)	isTyp(type,src)	return true if string is of given type
item3	EnDe.join(type,mode,_n3_,src,prefix,suffix,delimiter)	join(type,mode,_n3_,src,prefix,suffix,delimiter)	global replace newlinw or tab character
item3	EnDe.join('arg',mode,_n3_,src,prefix,suffix,delimiter)	join('arg',mode,_n3_,src,prefix,suffix,delimiter)	arg: global replace newline by &
item3	EnDe.join('key',mode,_n3_,src,prefix,suffix,delimiter)	join('key',mode,_n3_,src,prefix,suffix,delimiter)	key: global replace tabs by =
item3	EnDe.join('del',mode,_n3_,src,prefix,suffix,delimiter)	join('del',mode,_n3_,src,prefix,suffix,delimiter)	del: global replace newline by given delimiter
item3	EnDe.split(type,mode,_n3_,src,prefix,suffix,delimiter)	split(type,mode,_n3_,src,prefix,suffix,delimiter)	global split
item3	EnDe.split('arg',mode,_n3_,src,prefix,suffix,delimiter)	split('arg',mode,_n3_,src,prefix,suffix,delimiter)	arg: global split, replace & by newline by &
item3	EnDe.split('key',mode,_n3_,src,prefix,suffix,delimiter)	split('key',mode,_n3_,src,prefix,suffix,delimiter)	key: global split, replace = by tabs by =
item3	EnDe.split('del',mode,_n3_,src,prefix,suffix,delimiter)	split('del',mode,_n3_,src,prefix,suffix,delimiter)	del: global split, replace given delimiter by newline
item3	EnDe.trim(src)	trim(src)	trim leading and trailing white spaces
item3	EnDe.chr2bytes(src)	chr2bytes(src)	convert (unicode) character to array of 1 or 2 bytes; src is a single character
item3	EnDe.str2bytes(src)	str2bytes(src)	convert (unicode) character string to array of bytes
item3	EnDe.chr2code(src)	chr2code(src)	convert plain text to JavaScript char codes (integer of unicode); src is a single character
item3	EnDe.chr2bin_DoesNotWork(type,src)	chr2bin_DoesNotWork(type,src)	convert character to n-bit binary string; src is a single character; type is number of bits
item3	EnDe.chr2bin(type,src)	chr2bin(type,src)	convert character to n-bit binary string; src is a single character; type is number of bits
item3	EnDe.java2chr(src)	java2chr(src)	convert char code to character using java.lang.Character()
item3	EnDe.code2chr(src)	code2chr(src)	convert JavaScript char codes (integer of unicode) to plain text
item3	EnDe.code2prn(src)	code2prn(src)	convert JavaScript char code (integer of unicode) to printable (ASCII) character
item3	EnDe.prn2code(src)	prn2code(src)	convert printable (ASCII) character to JavaScript char code (integer of unicode)
item3	EnDe.chr2prn(type,src)	chr2prn(type,src)	convert JavaScript character to printable (ASCII) character, non-printable are \xXX
item3	EnDe.chr2prn('null',src)	chr2prn('null',src)	null: convert non-printable to hex (no padding, see EnDe.i2h())
item3	EnDe.chr2prn('3',src)	chr2prn('3',src)	3:    convert non-printable to 3-digit hex (see EnDe.i2h())
item3	EnDe.chr2prn('n',src)	chr2prn('n',src)	n:    convert non-printable to n-digit hex (see EnDe.i2h())
item3	EnDe.str2bin(type,src,prefix,suffix,delimiter)	str2bin(type,src,prefix,suffix,delimiter)	convert string to n-bit binary string; type is number of bits
item3	EnDe.str2chr(src,prefix,suffix,delimiter)	str2chr(src,prefix,suffix,delimiter)	convert string to list of characters with prefix, delimiter and suffix
item3	EnDe.str2lng(src)	str2lng(src)	convert a string to an array of long integers
item3	EnDe.lng2str(src)	lng2str(src)	convert an array of long integers to a string
item3	EnDe.z2n(src)	z2n(src)	convert negative numbers to numbers (2^32)
item3	EnDe.n2z(src)	n2z(src)	convert numbers (2^32) to negative numbers
item3	EnDe.z2n64(src)	z2n64(src)	convert negative numbers to numbers (2^64)
item3	EnDe.n2z64(src)	n2z64(src)	convert numbers (2^64) to negative numbers
item3	EnDe.h2i(src)	h2i(src)	convert hex value (string) to integer
item3	EnDe.i2h(type,src)	i2h(type,src)	convert integer (string) value to hex
item3	EnDe.i2h('null',src)	i2h('null',src)	null: converted hex (no padding)
item3	EnDe.i2h('hex0',src)	i2h('hex0',src)	hex0: converted hex (no padding)
item3	EnDe.i2h('hex1',src)	i2h('hex1',src)	hex1: converted hex (no padding)
item3	EnDe.i2h('3',src)	i2h('3',src)	3:    converted 3-digit hex
item3	EnDe.i2h('n',src)	i2h('n',src)	n:    converted n-digit hex
item3	EnDe.h2c(src)	h2c(src)	convert hex value (string) to characters
item3	EnDe.h2b(src)	h2b(src)	convert hex value (string) to binary
item3	EnDe.b2h(src)	b2h(src)	convert binary value (string) to hex (binary limeted to 2^53)
item3	EnDe.i2b(src)	i2b(src)	convert integer (string) value to binary
item3	EnDe.b2i(src)	b2i(src)	convert binary value (string) to hex (binary limeted to 2^53)
item3	EnDe.i2bcd(src)	i2bcd(src)	convert digit to BCD code (4 dual digits)
item3	EnDe.bcd2i(src)	bcd2i(src)	convert BCD code (4 dual digits) to digit
item3	EnDe.reverse(src)	reverse(src)	reverse characters in string (mirror sring)
item3	EnDe.atbash(src)	atbash(src)	convert plain text to Atbash encoding
item3	EnDe.a2e(src)	a2e(src)	convert ASCII to EBCDIC characters
item3	EnDe.e2a(src)	e2a(src)	convert EBCDIC to ASCII characters
item3	EnDe.xor(src,key)	xor(src,key)	XOR each character with first character from key
item3	EnDe.rot(src,key)	rot(src,key)	convert string to rot-N-encoded text (aka Caesar encoding); key is number/position of character: 1..26
item3	EnDe.dez2hex(type,mode,uppercase,src,prefix,suffix,_n7_)	dez2hex(type,mode,uppercase,src,prefix,suffix,_n7_)	convert decimal encoded text to hex encoded text
item3	EnDe.dez2hex('null',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('null',mode,uppercase,src,prefix,suffix,_n7_)	null: converted hex value without prefix
item3	EnDe.dez2hex('qp2',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('qp2',mode,uppercase,src,prefix,suffix,_n7_)	qp2:  converted hex value prefixed with =
item3	EnDe.dez2hex('url2',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('url2',mode,uppercase,src,prefix,suffix,_n7_)	url2: converted hex value prefixed with %
item3	EnDe.dez2hex('url3',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('url3',mode,uppercase,src,prefix,suffix,_n7_)	url3: converted hex value prefixed with %0
item3	EnDe.dez2hex('url4',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('url4',mode,uppercase,src,prefix,suffix,_n7_)	url4: converted hex value prefixed with %00
item3	EnDe.dez2hex('ncr2',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('ncr2',mode,uppercase,src,prefix,suffix,_n7_)	ncr2: converted hex value prefixed with &#x
item3	EnDe.dez2hex('ncr4',mode,uppercase,src,prefix,suffix,_n7_)	dez2hex('ncr4',mode,uppercase,src,prefix,suffix,_n7_)	ncr4: converted hex value prefixed with &#x00
item3	EnDe.h2n(type,mode,uppercase,src,prefix,suffix,delimiter)	h2n(type,mode,uppercase,src,prefix,suffix,delimiter)	convert hex value to its nibble hex values (1-byte values supported only)
item3	EnDe.h2n('nibbles',mode,uppercase,src,prefix,suffix,delimiter)	h2n('nibbles',mode,uppercase,src,prefix,suffix,delimiter)	nibbles: convert hex value to its nibble hex values
item3	EnDe.h2n('nibble1',mode,uppercase,src,prefix,suffix,delimiter)	h2n('nibble1',mode,uppercase,src,prefix,suffix,delimiter)	nibble1: convert hex value to its first nibble hex value
item3	EnDe.h2n('nibble2',mode,uppercase,src,prefix,suffix,delimiter)	h2n('nibble2',mode,uppercase,src,prefix,suffix,delimiter)	nibble2: convert hex value to its second nibble hex value


group	EnDe.IP	EnDe.IP	EnDe.IP
item3	EnDe.IP.ip2num(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	ip2num(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert dotted quad IP address to integer
item3	EnDe.IP.ip2big(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	ip2big(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert dotted quad IP address to long integer
item3	EnDe.IP.ip2xeh(_n1_,_n2_,uppercase,src,prefix,_n6_,delimiter)	ip2xeh(_n1_,_n2_,uppercase,src,prefix,_n6_,delimiter)	convert dotted quad IP address to hex value
item3	EnDe.IP.ip2hex(type,mode,uppercase,src,prefix,_n6_,delimiter)	ip2hex(type,mode,uppercase,src,prefix,_n6_,delimiter)	convert dotted quad IP address to dotted hex
item3	EnDe.IP.ip2hex('url',mode,uppercase,src,prefix,_n6_,delimiter)	ip2hex('url',mode,uppercase,src,prefix,_n6_,delimiter)	url: convert dotted quad IP address to dotted url-encoded hex
item3	EnDe.IP.ip2hex('hex',mode,uppercase,src,prefix,_n6_,delimiter)	ip2hex('hex',mode,uppercase,src,prefix,_n6_,delimiter)	hex: convert dotted quad IP address to dotted hex
item3	EnDe.IP.ip2hex('xeh',mode,uppercase,src,prefix,_n6_,delimiter)	ip2hex('xeh',mode,uppercase,src,prefix,_n6_,delimiter)	xeh: convert dotted quad IP address to hex value (wrapper for .IP.ip2xeh())
item3	EnDe.IP.ip2oct(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	ip2oct(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert dotted quad IP address to dotted octal
item3	EnDe.IP.ip2bin(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	ip2bin(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert dotted quad IP address to dotted binary
item3	EnDe.IP.ip2bit(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	ip2bit(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert dotted quad IP address to plain binary
item3	EnDe.IP.ip2ip6(type,mode,uppercase,src,prefix,_n6_,delimiter)	ip2ip6(type,mode,uppercase,src,prefix,_n6_,delimiter)	convert dotted quad IP address to dotted IPv6
item3	EnDe.IP.ip62ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	ip62ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert dotted IPv6 to dotted quad IP address
item3	EnDe.IP.bit2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	bit2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert binary address to dotted quad IP address
item3	EnDe.IP.num2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	num2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert integer address to dotted quad IP address
item3	EnDe.IP.big2ip(type,_n2_,_n3_,src,_n5_,_n6_,delimiter)	big2ip(type,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert long integer address to dotted quad IP address
item3	EnDe.IP.big2ip('big2ip',_n2_,_n3_,src,_n5_,_n6_,delimiter)	big2ip('big2ip',_n2_,_n3_,src,_n5_,_n6_,delimiter)	big2ip: convert long (64-bit) integer address to dotted quad IP address
item3	EnDe.IP.big2ip('low2ip',_n2_,_n3_,src,_n5_,_n6_,delimiter)	big2ip('low2ip',_n2_,_n3_,src,_n5_,_n6_,delimiter)	low2ip: convert long (32-bit) integer address to dotted quad IP address
item3	EnDe.IP.arr2ip(base,arr,arrsize,delimiter)	arr2ip(base,arr,arrsize,delimiter)	build dotted quad IP from given array; internal function, should not be used in API
item3	EnDe.IP.xeh2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	xeh2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert hex value to dotted quad IP address
item3	EnDe.IP.hex2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	hex2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert Hex address to dotted quad IP address
item3	EnDe.IP.oct2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	oct2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert octal address to dotted quad IP address
item3	EnDe.IP.bin2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	bin2ip(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	convert binary address to dotted quad IP address
item3	EnDe.IP.reverse(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	reverse(_n1_,_n2_,_n3_,src,_n5_,_n6_,delimiter)	reverse dotted IP address
item3	EnDe.IP.dispatch(type,mode,uppercase,src,prefix,suffix,delimiter)	dispatch(type,mode,uppercase,src,prefix,suffix,delimiter)	dispatcher for IP functions


group	EnDe.IDN	EnDe.IDN	EnDe.IDN
item3	EnDe.IDN.libidn(src,suffix)	libidn(src,suffix)	check for trailing suffix and remove it
item3	EnDe.IDN.str2puny(src)	str2puny(src)	convert plain text to punycode
item3	EnDe.IDN.str2idn(src)	str2idn(src)	convert plain text to IDN/punycode
item3	EnDe.IDN.puny2str(src)	puny2str(src)	convert punycode to plain text
item3	EnDe.IDN.idn2str(src)	idn2str(src)	convert IDN/punycode plain text


group	EnDe.CRC	EnDe.CRC	EnDe.CRC
item3	EnDe.CRC.reflectByte(src)	reflectByte(src)	reflect one byte
item3	EnDe.CRC.reflect(src,bitnum,startLSB)	reflect(src,bitnum,startLSB)	reflect 'bitnum' bits starting at lowest bit = startLSB
item3	EnDe.CRC.c8tab(src,iv,mask,polynomial)	c8tab(src,iv,mask,polynomial)	compute CRC-8 checksum
item3	EnDe.CRC.crc16(src,iv,mask,polynomial)	crc16(src,iv,mask,polynomial)	compute CRC-16 checksum
item3	EnDe.CRC.c16arc(src,iv,mask)	c16arc(src,iv,mask)	compute CRC-16 checksum using classic table (ARC)
item3	EnDe.CRC.c16ppp(src,iv,mask)	c16ppp(src,iv,mask)	compute CRC-16 checksum using RFC-1662 table (aka PPP, aka FCS-16)
item3	EnDe.CRC.c16zmo(src,iv,mask)	c16zmo(src,iv,mask)	compute CRC-16 checksum using ZModem table
item3	EnDe.CRC.c32tab(src,iv,mask)	c32tab(src,iv,mask)	compute CRC-32 checksum (aka FCS-32)
item3	EnDe.CRC.dispatch(type,src,iv,mask,polynomial)	dispatch(type,src,iv,mask,polynomial)	wrapper for CRC functions


group	EnDe.Blowfish.DE	EnDe.Blowfish.DE	EnDe.Blowfish.DE
item3	EnDe.Blowfish.DE.blowfish(key,src)	blowfish(key,src)	


group	EnDe.B64.EN	EnDe.B64.EN	EnDe.B64.EN
item3	EnDe.B64.EN.b_N(type,src,linewrap)	b_N(type,src,linewrap)	convert plain text to BaseXX encoded text
item3	EnDe.B64.EN.b_N('base16',src,linewrap)	b_N('base16',src,linewrap)	base16:   Base16
item3	EnDe.B64.EN.b_N('base26',src,linewrap)	b_N('base26',src,linewrap)	base26:   Base26
item3	EnDe.B64.EN.b_N('base32',src,linewrap)	b_N('base32',src,linewrap)	base32:   Base32
item3	EnDe.B64.EN.b_N('base32c',src,linewrap)	b_N('base32c',src,linewrap)	base32c:  Base32 (Crockford alphabet)
item3	EnDe.B64.EN.b_N('base32h',src,linewrap)	b_N('base32h',src,linewrap)	base32h:  Base32hex
item3	EnDe.B64.EN.b_N('base32z',src,linewrap)	b_N('base32z',src,linewrap)	base32z:  z-Base32
item3	EnDe.B64.EN.b_N('base34',src,linewrap)	b_N('base34',src,linewrap)	base34:   Base34
item3	EnDe.B64.EN.b_N('base36',src,linewrap)	b_N('base36',src,linewrap)	base36:   Base36
item3	EnDe.B64.EN.b_N('base52',src,linewrap)	b_N('base52',src,linewrap)	base52:   Base52
item3	EnDe.B64.EN.b_N('base64',src,linewrap)	b_N('base64',src,linewrap)	base64:   Base64 as in RFC1521, RFC2045, RFC3548, RFC4648
item3	EnDe.B64.EN.b_N('base64f',src,linewrap)	b_N('base64f',src,linewrap)	base64f:  modified Base64 for filenames, SAP
item3	EnDe.B64.EN.b_N('base64p',src,linewrap)	b_N('base64p',src,linewrap)	base64p:  modified Base64 for program identifiers (var. 1)
item3	EnDe.B64.EN.b_N('base64q',src,linewrap)	b_N('base64q',src,linewrap)	base64q:  modified Base64 for program identifiers (var. 2)
item3	EnDe.B64.EN.b_N('base64r',src,linewrap)	b_N('base64r',src,linewrap)	base64r:  modified Base64 for regular Expressions
item3	EnDe.B64.EN.b_N('base64u',src,linewrap)	b_N('base64u',src,linewrap)	base64u:  modified Base64 for URL, RFC4648
item3	EnDe.B64.EN.b_N('base64x',src,linewrap)	b_N('base64x',src,linewrap)	base64x:  modified Base64 for XML name tokens
item3	EnDe.B64.EN.b_N('base64y',src,linewrap)	b_N('base64y',src,linewrap)	base64y:  modified Base64 for XML identifiers
item3	EnDe.B64.EN.b_N('base85',src,linewrap)	b_N('base85',src,linewrap)	base85:   Base85
item3	EnDe.B64.EN.b_N('base91',src,linewrap)	b_N('base91',src,linewrap)	base91:   basE91
item3	EnDe.B64.EN.b_N('base94',src,linewrap)	b_N('base94',src,linewrap)	base94:   base94
item3	EnDe.B64.EN.b_N('base95',src,linewrap)	b_N('base95',src,linewrap)	base95:   base95
item3	EnDe.B64.EN.b64(src,linewrap)	b64(src,linewrap)	convert plain text to Base64 encoded text
item3	EnDe.B64.EN.u64(src,linewrap)	u64(src,linewrap)	convert plain text to Url64 encoded text
item3	EnDe.B64.EN.b62(_n1_,_n2_,_n3_,src,_n5_,_n6_,linewrap)	b62(_n1_,_n2_,_n3_,src,_n5_,_n6_,linewrap)	convert plain text to Base62 encoded text
item3	EnDe.B64.EN.dispatch(type,_n2_,_n3_,src,_n5_,_n6_,linewrap)	dispatch(type,_n2_,_n3_,src,_n5_,_n6_,linewrap)	wrapper for base-XX functions


group	EnDe.SHA	EnDe.SHA	EnDe.SHA
item3	EnDe.SHA.safe_add(x, y)	safe_add(x, y)	
item3	EnDe.SHA.rol(num, cnt)	rol(num, cnt)	
item3	EnDe.SHA.str2binb(str)	str2binb(str)	
item3	EnDe.SHA.binb2str(bin)	binb2str(bin)	
item3	EnDe.SHA.binb2hex(binarray)	binb2hex(binarray)	
item3	EnDe.SHA.binb2b64(binarray)	binb2b64(binarray)	


group	EnDe.B64.DE	EnDe.B64.DE	EnDe.B64.DE
item3	EnDe.B64.DE.b_N(type,src)	b_N(type,src)	convert BaseXX encoded text to plain text
item3	EnDe.B64.DE.b_N('base16',src)	b_N('base16',src)	base16:   Base16
item3	EnDe.B64.DE.b_N('base26',src)	b_N('base26',src)	base26:   Base26
item3	EnDe.B64.DE.b_N('base32',src)	b_N('base32',src)	base32:   Base32
item3	EnDe.B64.DE.b_N('base32c',src)	b_N('base32c',src)	base32c:  Base32 (Crockford alphabet)
item3	EnDe.B64.DE.b_N('base32h',src)	b_N('base32h',src)	base32h:  Base32hex
item3	EnDe.B64.DE.b_N('base32z',src)	b_N('base32z',src)	base32z:  z-Base32
item3	EnDe.B64.DE.b_N('base36',src)	b_N('base36',src)	base36:   Base36
item3	EnDe.B64.DE.b_N('base52',src)	b_N('base52',src)	base52:   Base52
item3	EnDe.B64.DE.b_N('base64',src)	b_N('base64',src)	base64:   Base64 as in RFC1521, RFC2045, RFC3548, RFC4648
item3	EnDe.B64.DE.b_N('base64f',src)	b_N('base64f',src)	base64f:  modified Base64 for filenames, SAP
item3	EnDe.B64.DE.b_N('base64p',src)	b_N('base64p',src)	base64p:  modified Base64 for program identifiers (var. 1)
item3	EnDe.B64.DE.b_N('base64q',src)	b_N('base64q',src)	base64q:  modified Base64 for program identifiers (var. 2)
item3	EnDe.B64.DE.b_N('base64r',src)	b_N('base64r',src)	base64r:  modified Base64 for regular Expressions
item3	EnDe.B64.DE.b_N('base64u',src)	b_N('base64u',src)	base64u:  modified Base64 for URL, RFC4648
item3	EnDe.B64.DE.b_N('base64x',src)	b_N('base64x',src)	base64x:  modified Base64 for XML name tokens
item3	EnDe.B64.DE.b_N('base64y',src)	b_N('base64y',src)	base64y:  modified Base64 for XML identifiers
item3	EnDe.B64.DE.b64(src)	b64(src)	convert Base64 encoded text to plain text
item3	EnDe.B64.DE.u64(src)	u64(src)	convert Url64 encoded text to plain text
item3	EnDe.B64.DE.dispatch(type,mode,_n3_,src,_n5_,_n6_,_n7_)	dispatch(type,mode,_n3_,src,_n5_,_n6_,_n7_)	wrapper for base-XX functions; mode may be used to allow "Impedanz Mismatch"
item3	EnDe.B64.DE.dispatch(type,'strict',_n3_,src,_n5_,_n6_,_n7_)	dispatch(type,'strict',_n3_,src,_n5_,_n6_,_n7_)	strict:  allow valid chars only and need proper padding
item3	EnDe.B64.DE.dispatch(type,'lazy',_n3_,src,_n5_,_n6_,_n7_)	dispatch(type,'lazy',_n3_,src,_n5_,_n6_,_n7_)	lazy:    allow valid chars only but padding is optional
item3	EnDe.B64.DE.dispatch(type,'verbose',_n3_,src,_n5_,_n6_,_n7_)	dispatch(type,'verbose',_n3_,src,_n5_,_n6_,_n7_)	verbose: invalid characters are ignored, padding is optional



menu	EnDeFunc.txt	EnDe functions:	EnDe function call
inside	EnDeDOM.f.FF
id	EnDeDOM.f.FF.func
html	SELECT
size	1
onClick	return EnDeGUI.dispatch(this,this.value);
use	EnDe
use	EnDe.AES.DE
use	EnDe.AES.EN
use	EnDe.B64
use	EnDe.B64.DE
use	EnDe.B64.EN
use	EnDe.Blowfish
use	EnDe.Blowfish.DE
use	EnDe.Blowfish.EN
use	EnDe.CRC
use	EnDe.DE
use	EnDe.EN
use	EnDe.HTTP
use	EnDe.HTTP.DE
use	EnDe.HTTP.EN
use	EnDe.HTTP.req
use	EnDe.HTTP.res
use	EnDe.IDN
use	EnDe.IP
use	EnDe.IP.ipv6
use	EnDe.MD4
use	EnDe.MD5
use	EnDe.RMD
use	EnDe.SHA
use	EnDe.SHA.sha1
use	EnDe.SHA.sha1.hmac
use	EnDe.SHA.sha2
use	EnDe.SHA5
use	EnDe.TS
use	EnDe.UCS
